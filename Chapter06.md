
在第1章中，我们学会了在何处找到软件包和安装软件包。软件包在本质上是一堆函数的集合（甚至可能是脚本），这些函数与一些特定的科学领域或者编程领域。比如，金融软件包含有用于解决金融问题的函数，多核软件包提供了多核CPU的函数。

在本章里，读者会学会如何制作自己的软件包。该软件包可以用来求解一维和二维Possion方程。选择这个经典的例子是因为数学理论相对简单，编程部分并不复杂，更重要的是该软件包可以用于求解许多在工程中遇到的有意思的问题，比如流体力学，生物群体动力学，甚至更多。

这个章节被分成3个部分。在第1部分，讨论了Poisson方程在热传导问题中的应用。如果读者已经熟悉Poisson方程，可以跳过这一部分。第2部分涉及我们用于Poisoon的算法。在第3部分中，我们实现了求解程序，制作了软件包。

阅读完这章后，读者会学会：

 - 如何制作Octave软件包
 - 有限元算法
 - 如何在Octave中运用稀疏矩阵
 - 如何运用Octave来求解Posisson方程的数值解

本章的主要目的是说明读者如何制作Octave软件包，因此，我们对于有限元算法没有作进一步深入研究，一些高级教科书跟这个主题有关的里有详细的叙述。有兴趣的读者，我推荐下面的材料：

 1. “Computation Fluide Dynamics-the basics with applications",J. Anderson Jr.  McGraw-Hill(1995)
 2. "Numerical Recipe: The Art of Scientific Computing,3rd Edition", Press et al. Cambridge University Press(2007)
 3. "Computational Methods for Flui Dynamics",J. H. Ferziger and M. Peric, Springer-Verlag(1999)
 4. "Partial Differential Equations for Scientists and Engineers", S.J. Farlow,Dover Pubulications(1993)

**Poisson 方程-热传导的两个例子**

我们所有人对于热和温度具有直观的认识，所以解说Poisson方程的最容易的方式可能是通过热传导方程。


**一维热传导**
假设一个金属加热器，长度为L，架设于两条电线之间，温度为$T_0$。金属加入器被一个加热器覆盖，
这一位我们的热量会沿着惊醒方法加入，热量最终会到达终点。一个明显的问题是：金属加热器里的温度是多少？在我们回答这个问题之前。我们指定我们只对最终的温度感兴趣，而不是我们开关时的温度。这个被称为稳态温度。

为了回答这个问题，我们首先需要写出热传导方程。如果哦啊我们让金属棒的x方向，我们如果假设温度在其他方向不会发生变动，方程为：

$$\frac{\partial^2T(x)}{\partial x^2} = -\frac{Q}{K}$$

其中T(x)为温度分布，k为热传导系数。对于金而言，k大约为319w/k（室温）。公式有时。

现在方程（6.1）为偏微分方程，为一维Poisson方程的一个实例。为求解微分方程，我们必须指定边界条件。这里只是剪刀给出了电线的温度，即：

$$T(0)=T_0 and T(L)=T_0,  $$

实际上，通过直接积分当否和方程（6.2）求解方程（6.1）是可能的。得到了：

$$T(x)=\frac{Q}{2K}x(L-x)+T_0$$

即温度分布为抛物线，在x=L/2时，具有最大值。方程（6.3）即为Poisson方程的解。我们可以很容易地检查这个推论是否正确。通过对方程（6.3）简单地二次求导就可以了。

Poisson方程是椭圆偏微分方程的一个实例，也是一个边界值问题。

**二维热传导问题**

一维热传导问题可以扩展至二维的情形。比如，一块板（给定材料）可以连接至热电线，正如下面图片种所示。该板被独立的材料，热量只能从。如果平板足够“平”，我们假设温度在纵向是均一的。

在这种情形下。热传导方程为：

$$\frac{\partial^2T(x,y)}{\partial x^2} + \frac{\partial^2T(x,y)}{\partial y^2} =0$$



**插曲：稀疏矩阵**

你可能已经注意到，系数矩阵中大部分的矩阵元素为0值。比如，对于二维矩阵问题，100个网格的系数矩阵有100万的元素，但是只有48416个元素为非零值（）。具有这种结构的矩阵被称之为稀疏矩阵。如果我们将矩阵中素偶又的元素（零值和非零值），我们会需要800MB的内存，这种方式不是我们所需要的。幸运的是，我们可以告诉Octave，一个矩阵式稀疏的，Octave为非零值准备内存。

**实战时刻-初始化稀疏矩阵**

1. Octave中，我们可以定义矩阵为稀疏矩阵，使用sparse函数。最简单的初始化稀疏矩阵，总共5行和6列，为：

        octave:1> A=sparse(5,6)

2. 将非零值赋值给矩阵，你简单地使用通常的赋值方式，比如：

        octave:2> A(1,2)=42;A(3,:)=3;
        octave:3>

3. 使用full函数来解压整个矩阵（包括所有零值）：

        octave:4 B=full(A)

**刚刚发生了什么**

命令1中返回的信息告诉我们，Octave将变量解析成5行6列的矩阵。nnz变量告诉我们非零值的数目。这里，还没有元素被初始化，因此nnz为0.
命令2后，我们会看到有7个非零元素，占总元素的23%.注意到稀疏矩阵中的元素以跟我们以往不同的方式打印。括号表示行数和列数索引所有非零值的索引。

你可以对稀疏矩阵进行操作，同你对正常的矩阵数值，稀疏矩阵也可以函有复数元素。

创建稀疏矩阵不是很有效，因为每次我们将一个值赋值给矩阵，Octave必须重新调整内存（因此，需要与操作系统进行通讯）。如果你需要输入许多元素时，会大大增加运行时间。如果你能够提前知道矩阵中非零元素的数目，你可以通过另外一种方式来创建稀疏矩阵。为了在这里不迷失在细节里，我们会使用上面这种比较简单的方法来生成，因为能够满足我们的需求。

**内存的使用**

你可以看到Octave使用了多少内存来存储变量A（命令1-2）和变量B(命令4)，使用whos命令。A占用了112个字节，而B占用了240个字节（30个双精度浮点数，每个8个字节）。你也许认为A会占用56个字节，而不是112个。原因是因为Octave为了追述非零元素的位置，占用了另外的字节。因此，只对函数足够多0值的矩阵使用稀疏矩阵。

我们现在来实现Poisson解法器

**函数实现和打包**

上面，我们需要求解方程：
$$A\varphi=b$$
其中A为系数矩阵，方程（6.1）中给出，$\varphi$为我们需要求找的向量，比如，上的温度。向量b。

为了求解Possoin方程，我们至少需要：
1. 指定源术语和边界值；
2. 生成系数矩阵；
3. 求解线性方程；

此外，我们需要在向量和矩阵之间进行转换，我们仅需要生成系数矩阵。我们必须编写一个Octave函数来生成一维Possoin方程的矩阵，另外一个函数来生成二维Poisson方程的矩阵

**一维方程系数矩阵**

函数cmat_1d生成方程（5.6）中的系数矩阵，由下面代码示例6.1中给出：

从代码示例6.1中，我们看到用户调用单输入参数的函数，网格点数。代码第1-16行用于处理文档和函数调用验证，第18行，我们初始化输出函数，。第20行我们设定了边界点数。

从系数矩阵中，我们看到了每行有3个元素，值分别为1，-2，1.如果行表示内部网格点，我们将这3个值赋值给正确的矩阵元素，通过for循环（第22-24行），用一个向量化的命令来避免套嵌循环。

再一次，我们强调一线，对于非常大的矩阵，定义稀疏矩阵式不合理的。因为每次我们都要重新调整内存。本章后面的练习里，你会被要求用不同方式来初始化
矩阵，实现一个优化过的cmat_1d版本。

**二维方程系数矩阵**

二维Poisson方程的系数矩阵有点复杂，因为边界点，但是它遵循代码示例6.1中的同样的基本想法。我会省去文档部分和函数调用检查：

这里代码第8-9行会提取边界点。第1个和第2个中选出边界点的最大值和最小值。

**转换函数**

**测试函数**

我们开始求解物理问题之前，必须检查3函数正如希望的方式工作。

**系数矩阵**

cmat_1d和cmat_2d函数，生成了一维和二维线性系数矩阵。我们会检查每个函数的输出，通过逐个打印函数，这是个很乏味的工作，你可能会错过一些错误（我知道）我们应该做出一个矩阵的图形表示方式。这里，imagesc函数很方便。

**pois-solv软件包**

我们现在可以集合4个函数cmat_1d,cmat_2d，vecmat_convert和pois_fd函数至单个Octave软件包。将函数打包，而不是复制单个m文件，有一些好处：

- 文件会被归档至单个标准文件格式。
- 你可以使用pkg命令安装软件包，载入和卸载函数，而不用关心函数的安装位置（即，如果它们在Octave的搜索路径里）
- 使用软件包，你可以加入一些关于函数的一些信息。
- 你可以上传软件包至Octave-forge。

为了正确打包函数，我们需要做一些工作。

**安排文件至软件包路径**

首先，你会需要一个软件包路径-我们将该目录命名为poissolv，但是你可以调用所有你想要的东西。软件包的目录里，我们需要下列文件和目录：

1. DESCRIPTION文件：该文本文件包含软件包的描述，比如，版本号和作者。该文件是必须的。
2. COPYING文件：license软件包。我们应使用GNU General Public License 第3版或者更新的版本。该文件是必须的。主力，该license会影响软件包的应用。
3. INDEX文件：文本文件中列出了。
4. inst目录：该目录包含所有的软件包m文件。不是必须的，如果软件包里包含m文件（通常都是），inst目录就是必须的。

让我们逐个看一下例子：

**DESCRIPTION文件**

DESCRIPTION文件的例子如下面所示：


第1行使用了井号，就像脚本和函数中的注释。第2-11行，我们列出了软件包名，版本号，日期等等。每行以关键词开始,比如,Version.关键词会被软件包程序识别，大部分关键词会被包含于文件中。上面列出的软件包是必须的。你也可以提供一个网页链接，如果需要附加的信息，可以使用Url命令来查找。

新行中以空格键开始（第8-11行）会被软件包解释成续行操作。

**COPYING文件**

用户必须告知软件包授权方式。如果
