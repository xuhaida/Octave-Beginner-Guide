
<script type="text/javascript" async
 src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

*速度的需求：优化和动态链接函数*

正如我们已经多次看到，只要向量化自己的代码，并使用内置函数。你就很少需要做什么使得代码运行。事情就应如此。Octave主要为科学家和工程师设计。他（她）们应该主要考虑科学问题，而不是调制代码执行地更好。但是，有时会碰到数值问题不大容易甚至无法向量化或者没有内置机制存在。本章里，你会看到在这种情形下有什么可能性

本章分为2部分，来解释两个主要的方法你可能想到：

1. 优化Octave代码；

2. 用C或者C\++这些底层语言来实现代码，连接至Octave工作区。使用Octave C++库和接口需要提醒的是Octave还没有profiler（profiler能够检查代码执行差的部分代码的工具）。有提示，Octave会在将来的版本中支持profiler。但是目前我们依靠经验和简单的测试策略。

总而言之，我么会讨论：

* 使用tic和toc来计算函数和脚本时间；

* 一些技术可以应用于你的Octave代码来改进性能；

* 如何使用Octave C++函数和库和接口与Octave函数而不是Octave本身的语言；

* 如何编译C++代码，如何在Octave命令提示中调用函数

优化C++代码的一些方法

最重要的是，我们会看到内置功能和运算操作符Octave本身是非常快的。
只用于简单的算法和C++代码。

**一些优化技巧**

一些事情你要考虑到，当你希望优化你的Octave代码。

其中一些是：

1. 避免循环，特别是套嵌循环。总是试着向量化你的代码。

2. 使用Octave内置功能，比如不要试着实现传统的线性方程解决。因为你想比Octave做得更好是不可能的。

3. 初始化你的数组变量，在进入循环之前，尽量来减少内存重排，带来与操作系统相关的overhead。

4. 如果你要部分向量，逐列循环。

5. 清理大数组，任何时候不用的时候及时清除，如此一来，你可以避免使用芯片内存中最慢的部分。

6. 在一些情况下，函数跑得比脚本快。因此，将脚本转化为一个函数，如果该脚本被多次调用。因为函数在Octave中被调用一次（它们只是首次调用时载入，而脚本会被多次载入）。

第6条只对绝望的人们有效，让我们通过一个简单的矩阵加法来解释这些要点。

在我们跳入之前，我们需要一些计时器来计时我们的命令和我们的代码块。自然地，这些在Octave中也已经实现。

**tic，toc**

tic和toc函数经常成对出现，给出你在tic和toc函数之间命令的执行时间，这也被成为wall time。基本上，tic启动时钟。而toc返回wall-time，你可能因此拥有多个toc，而起始时间只有一个。如果你有许多进程运行于你的机器上，会拖慢你命令的运行时间，会拖长walltime，你可以测定CPU的消耗实际时间，我们会仅仅使用walltime，因此，是CPU很好的近似。

**实战时刻--使用tic和toc**

让我们首先使用tic和toc来得到walltime，来计算两个矩阵使用向量化方式：

        octave: 1>A=rand(1000,1000);B=rand(1000,1000);
        octave: 2>tic();C=A+B;toc();
        Elapse time is 0.015 seconds

花了15微秒时间计算2个1000*1000举证，即执行了100万次加法。

**刚才发生了什么**

在命令1中，我们声明了2个1000*1000大小的举证，所有成员来自于均匀分布[0,1]的数据。在命令2中，我们使用tic函数来启动计时器，加法2个矩阵，返回运行时间。我们可以将toc的输出赋值给一个变量。用于后面的计算。比如，命令2也可以如下所示：

        octave：2>tic();C=A+B;add-time=toc();
        add-time=0.015

**向量化**

我们再次说明向量化的重要性，不使用+运算符于2个矩阵之间。我们使用套嵌循环将成员加在一起：使用“传统”方式。

        octave：3>tic();for i=1:1000,j=

与向量化方法比较，速度慢了2000倍，同时命令3中，我们做了更多编码，也更容易出错。

**变量初始化**

我们如命令3一起将矩阵相加，但是我们

        octave：4>clear c
        octave: 5》

命令5运行时间比命令3慢了5秒，即使这两个完全一样。为什么会这样。在命令5中变量C会在工作区存在。意味着我们对变量A和B进行循环的时候，在命令运行时这么做当然消耗时间。

如果你对大的数组进行工作，预先知道大小，对数组使用zero函数进行初始化，是个不错的想法，比如说，我们假设C没有生命，我么可以使用：

        octave: 6>c=zeros(1000,1000);

在这种情况下，只需要一次。

**逐行和逐列运行**

在矩阵相加算法中，我们可以发现逐行和逐列循环是存在差别的。在Octave中使用逐行还是逐列循环在性能上是有差别的。下面的2个来解释这种现象。

首先我们对列进行循环，（因此，执行逐列向量化）：

        octave：7>

然后我们逐行循环，因此逐列循环比逐行循环快2倍，这种差别与数组在内存上的存储方式有关，如果你使用for或者while运行循环时，如果可能的话，考虑逐列方式。

**动态链接函数**

在一些情况下，你可能不可避免地使用循环，比如，你可能希望使用特别的数值差分方程组，该方法优于Octave的lsod，一个好的观点解释了为什么lsod没有达到你的要求。其次，存在odepkg包，提供了很多不同类型的solver。在这种情况下，你必须实现自己的函数，你可能使用如C，C++之类的底层语言来实现。然后链接至Octave，链接过程也能使用其他，因此，使得Octave的扩展是无限制的。

在底层代码和Octave解释器之间存在接口，Octave的原生接口也是基于C\++的。但是你也可以使用Matlab Mex接口。我们将会局限于前者，正如我们在前言中提到的，我们希望你能拥有C++的基本知识。

DEFUN_DLD宏

C++接口基于宏DEFUN_DLD(名称来源于GNU动态链接器dld)，DEFUN_DLD的基本接口：

        DEFUN_DLD(function name,input argument list,
          number of inputs, help doc)

其中参数：

function name：简单地描述函数名称，名称必须与文件名一致，无扩展名。

input arguments list:变量包含了

number of inputs:

help string

宏总是返回类型变量octave_value_list,甚至这个会被明确指定。

**实战时刻--编写“hello world”程序**

1. 让我们编写经典的”hello world”程序，打开你的编辑器，输入你的代码:

        代码实例8.1
        #include <octave/oct.h>

        DEFUN_DLD(hello,argv,,"Usage: hello()"){
          octave_value_list retval;

          octave_stdout<< "Hello World\n";

          return retval;
        }

2. 将文件保存为hello.cc至你的工作目录下，在Octave提示符下输入下面的命令：

        octave： >mkoctfile hello.cc

对C++代码进行编译。

3. 调用函数，会动态链接至Octave环境：

        octave：11>hello()
        hello,world

**发生了什么**

要使用Octave C++接口和库，我们需要包含头文件oct.h,在代码示例8.1的第3行引入。我们将函数名设定成hello，将输入参数列表设定成argv，我们没有指定参数数目，因为用不到。如果我们使用help命令，帮助文本会显示：

        octave：12>help hello

第4行里，我们初始化一个对象，类型为octave_value_list,使用通用名称retval。正如前面提及的，DEFUN_DLD必须返回一个该类型的变量。第5行里，我们将字符串“hello world”发至标准输出。第8行，我们返回retval，然后退出函数。

默认情况下，文件名必须与函数名相同，因此，这儿我们将文件保存为hello.cc。因此，命令8编译文件，产生一个二进制文件hello.oct。因此，命令名为mkoctfile，是”make oct file”的缩写。这个对象文件链接至Octave解释器。

**管理输入参数和输出参数**

跟m函数一样，你应该可以用不同数目的输出参数来调用oct函数。该函数里，我们因此需要检查该函数是如何被调用的。并且如果不能正确的使用。我们应该可以发出警告或者错误信息。

幸运的是，实用Octave C++库文件做这件事是相当简单的。正如我们前面提及的，参数会通过类octave_value_list发送至实际是数组octave_value,对象类型octave可以使是矩阵，向量或者标量。

**实战时刻--检查用户输入和输出**

1. 代码示例8.2展示了一个函数args实例，该函数可以输入任意数目的输入参数，检查它们的类型，将这个输出至Octave命令提示符。该会返回数字从1到输入参数的数目：

        代码示例8.2


2. 我们当然用mkoctfile来编译这个文件，编译完后，尝试命令：

        octave：13>[a b c]=args(c)

3. 我们可以试一下复数标量输入参数:

**刚刚发生了什么**

代码示例前7行很直截了当的。第8行，我们调用方法method，返回参数列表的长度，即输入参数的数目。用户调用函数时，我们打印这个至命令行提示符中。

11-14行里，我们检查输出变量的数目是否超过了输入参数数目。如果发生这种情况，我们会打印一个错误信息，并返回函数。这种检查是必要的。如果你想避免警告信息，比如[a b]=args.

第16-29行的循环代码里，我么检查了每个参数的类型，你也许会感到迷惑，argv中数组成员的进入需要使用。

括号 ，通常的方括号，括号运算符在C\++中是有效的，调用时为你做了更多的检查。值得注意的是，该接口遵循通常的C++惯用法，因此，第一个索引为0。

列出可能的类型是非常累人的。这里，我们只是检查了4种不同的类型：string，real scalar，real matrice和complex。这些是通过方法25.所有这些方法返回布尔值（true或者false）依赖于变量的类型。

第28行里，我们将参数数目加入只返回值种，octave_value，我们实用append方法。参数通常为octave_value，并且我们因此将整数n+1转换成合适的类型，使用octave_value(n+1)。

命令13中的输出也学会让你感到惊奇
