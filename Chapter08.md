
<script type="text/javascript" async
 src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

*速度的需求：优化和动态链接函数*

正如我们已经多次看到，只要向量化自己的代码，并使用内置函数。你就很少需要做什么使得代码运行。事情就应如此。Octave主要为科学家和工程师设计。他（她）们应该主要考虑科学问题，而不是调制代码执行地更好。但是，有时会碰到数值问题不大容易甚至无法向量化或者没有内置机制存在。本章里，你会看到在这种情形下有什么可能性

本章分为2部分，来解释两个主要的方法你可能想到：

1. 优化Octave代码；

2. 用C或者C\++这些底层语言来实现代码，连接至Octave工作区。使用Octave C++库和接口需要提醒的是Octave还没有profiler（profiler能够检查代码执行差的部分代码的工具）。有提示，Octave会在将来的版本中支持profiler。但是目前我们依靠经验和简单的测试策略。

总而言之，我么会讨论：

* 使用tic和toc来计算函数和脚本时间；

* 一些技术可以应用于你的Octave代码来改进性能；

* 如何使用Octave C++函数和库和接口与Octave函数而不是Octave本身的语言；

* 如何编译C++代码，如何在Octave命令提示中调用函数

优化C++代码的一些方法

最重要的是，我们会看到内置功能和运算操作符Octave本身是非常快的。
只用于简单的算法和C++代码。

**一些优化技巧**

一些事情你要考虑到，当你希望优化你的Octave代码。

其中一些是：

1. 避免循环，特别是套嵌循环。总是试着向量化你的代码。

2. 使用Octave内置功能，比如不要试着实现传统的线性方程解决。因为你想比Octave做得更好是不可能的。

3. 初始化你的数组变量，在进入循环之前，尽量来减少内存重排，带来与操作系统相关的overhead。

4. 如果你要部分向量，逐列循环。

5. 清理大数组，任何时候不用的时候及时清除，如此一来，你可以避免使用芯片内存中最慢的部分。

6. 在一些情况下，函数跑得比脚本快。因此，将脚本转化为一个函数，如果该脚本被多次调用。因为函数在Octave中被调用一次（它们只是首次调用时载入，而脚本会被多次载入）。

第6条只对绝望的人们有效，让我们通过一个简单的矩阵加法来解释这些要点。

在我们跳入之前，我们需要一些计时器来计时我们的命令和我们的代码块。自然地，这些在Octave中也已经实现。

**tic，toc**

tic和toc函数经常成对出现，给出你在tic和toc函数之间命令的执行时间，这也被成为wall time。基本上，tic启动时钟。而toc返回wall-time，你可能因此拥有多个toc，而起始时间只有一个。如果你有许多进程运行于你的机器上，会拖慢你命令的运行时间，会拖长walltime，你可以测定CPU的消耗实际时间，我们会仅仅使用walltime，因此，是CPU很好的近似。

**实战时刻--使用tic和toc**

让我们首先使用tic和toc来得到walltime，来计算两个矩阵使用向量化方式：

        octave: 1>A=rand(1000,1000);B=rand(1000,1000);
        octave: 2>tic();C=A+B;toc();
        Elapse time is 0.015 seconds

花了15微秒时间计算2个1000*1000举证，即执行了100万次加法。

**刚才发生了什么**

在命令1中，我们声明了2个1000*1000大小的举证，所有成员来自于均匀分布[0,1]的数据。在命令2中，我们使用tic函数来启动计时器，加法2个矩阵，返回运行时间。我们可以将toc的输出赋值给一个变量。用于后面的计算。比如，命令2也可以如下所示：

        octave：2>tic();C=A+B;add-time=toc();
        add-time=0.015

**向量化**

我们再次说明向量化的重要性，不使用+运算符于2个矩阵之间。我们使用套嵌循环将成员加在一起：使用“传统”方式。

        octave：3>tic();for i=1:1000,j=

与向量化方法比较，速度慢了2000倍，同时命令3中，我们做了更多编码，也更容易出错。

**变量初始化**

我们如命令3一起将矩阵相加，但是我们

        octave：4>clear c
        octave: 5》

命令5运行时间比命令3慢了5秒，即使这两个完全一样。为什么会这样。在命令5中变量C会在工作区存在。意味着我们对变量A和B进行循环的时候，在命令运行时这么做当然消耗时间。

如果你对大的数组进行工作，预先知道大小，对数组使用zero函数进行初始化，是个不错的想法，比如说，我们假设C没有生命，我么可以使用：

        octave: 6>c=zeros(1000,1000);

在这种情况下，只需要一次。

**逐行和逐列运行**

在矩阵相加算法中，我们可以发现逐行和逐列循环是存在差别的。在Octave中使用逐行还是逐列循环在性能上是有差别的。下面的2个来解释这种现象。

首先我们对列进行循环，（因此，执行逐列向量化）：

        octave：7>

然后我们逐行循环，因此逐列循环比逐行循环快2倍，这种差别与数组在内存上的存储方式有关，如果你使用for或者while运行循环时，如果可能的话，考虑逐列方式。

**动态链接函数**

在一些情况下，你可能不可避免地使用循环，比如，你可能希望使用特别的数值差分方程组，该方法优于Octave的lsod，一个好的观点解释了为什么lsod没有达到你的要求。其次，存在odepkg包，提供了很多不同类型的solver。在这种情况下，你必须实现自己的函数，你可能使用如C，C++之类的底层语言来实现。然后链接至Octave，链接过程也能使用其他，因此，使得Octave的扩展是无限制的。

在底层代码和Octave解释器之间存在接口，Octave的原生接口也是基于C\++的。但是你也可以使用Matlab Mex接口。我们将会局限于前者，正如我们在前言中提到的，我们希望你能拥有C++的基本知识。

DEFUN_DLD宏

C++接口基于宏DEFUN_DLD(名称来源于GNU动态链接器dld)，DEFUN_DLD的基本接口：

        DEFUN_DLD(function name,input argument list,
          number of inputs, help doc)

其中参数：

function name：简单地描述函数名称，名称必须与文件名一致，无扩展名。

input arguments list:变量包含了

number of inputs:

help string

宏总是返回类型变量octave_value_list,甚至这个会被明确指定。

**实战时刻--编写“hello world”程序**

1. 让我们编写经典的”hello world”程序，打开你的编辑器，输入你的代码:

        代码实例8.1
        #include <octave/oct.h>

        DEFUN_DLD(hello,argv,,"Usage: hello()"){
          octave_value_list retval;

          octave_stdout<< "Hello World\n";

          return retval;
        }

2. 将文件保存为hello.cc至你的工作目录下，在Octave提示符下输入下面的命令：

        octave： >mkoctfile hello.cc

对C++代码进行编译。

3. 调用函数，会动态链接至Octave环境：

        octave：11>hello()
        hello,world

**发生了什么**

要使用Octave C++接口和库，我们需要包含头文件oct.h,在代码示例8.1的第3行引入。我们将函数名设定成hello，将输入参数列表设定成argv，我们没有指定参数数目，因为用不到。如果我们使用help命令，帮助文本会显示：

        octave：12>help hello

第4行里，我们初始化一个对象，类型为octave_value_list,使用通用名称retval。正如前面提及的，DEFUN_DLD必须返回一个该类型的变量。第5行里，我们将字符串“hello world”发至标准输出。第8行，我们返回retval，然后退出函数。

默认情况下，文件名必须与函数名相同，因此，这儿我们将文件保存为hello.cc。因此，命令8编译文件，产生一个二进制文件hello.oct。因此，命令名为mkoctfile，是”make oct file”的缩写。这个对象文件链接至Octave解释器。

**管理输入参数和输出参数**

跟m函数一样，你应该可以用不同数目的输出参数来调用oct函数。该函数里，我们因此需要检查该函数是如何被调用的。并且如果不能正确的使用。我们应该可以发出警告或者错误信息。

幸运的是，实用Octave C++库文件做这件事是相当简单的。正如我们前面提及的，参数会通过类octave_value_list发送至实际是数组octave_value,对象类型octave可以使是矩阵，向量或者标量。

**实战时刻--检查用户输入和输出**

1. 代码示例8.2展示了一个函数args实例，该函数可以输入任意数目的输入参数，检查它们的类型，将这个输出至Octave命令提示符。该会返回数字从1到输入参数的数目：

        代码示例8.2


2. 我们当然用mkoctfile来编译这个文件，编译完后，尝试命令：

        octave：13>[a b c]=args(c)

3. 我们可以试一下复数标量输入参数:

**刚刚发生了什么**

代码示例前7行很直截了当的。第8行，我们调用方法method，返回参数列表的长度，即输入参数的数目。用户调用函数时，我们打印这个至命令行提示符中。

11-14行里，我们检查输出变量的数目是否超过了输入参数数目。如果发生这种情况，我们会打印一个错误信息，并返回函数。这种检查是必要的。如果你想避免警告信息，比如[a b]=args.

第16-29行的循环代码里，我么检查了每个参数的类型，你也许会感到迷惑，argv中数组成员的进入需要使用。

括号 ，通常的方括号，括号运算符在C\++中是有效的，调用时为你做了更多的检查。值得注意的是，该接口遵循通常的C++惯用法，因此，第一个索引为0。

列出可能的类型是非常累人的。这里，我们只是检查了4种不同的类型：string，real scalar，real matrice和complex。这些是通过方法25.所有这些方法返回布尔值（true或者false）依赖于变量的类型。

第28行里，我们将参数数目加入只返回值种，octave_value，我们实用append方法。参数通常为octave_value，并且我们因此将整数n+1转换成合适的类型，使用octave_value(n+1)。

命令13中的输出也学会让你感到惊奇。该函数声明的首个输入参数为实数矩阵，但是输入是一个列向量。当然，这是因为OOctave能够区分1XN矩阵和列向量。

第2个参数被识别为字符串，但是也可以视为matrix。Octave简单地解读成字符数组或者字符矩阵。

命令14中，我们调用args复数变量，既然我们不能这个参数用is——，类型不会打印至屏幕。

**返回输入**

我们仍然需要获得输入，有时因为要进行实际计算，为了说明如何实施，让我们实现矩阵加法函数，运行+运算符所做的事情。

        代码示例8.3

代码13，14行里，我们开始初始化2个Matrix类型对象，该类型定义于OctaveC++
库文件。构造函数可以使用Matrix调用，比如第13行Matrix类型对象A
，使用相同数目的行数，列数组成。成员值作为第1个输入参数，构造函数也可以使用2个输入参数指定矩阵的维数，第19行种成员数值来初始化。

Matrix类拥有2个非常有用的方法rows和columns。分别返回矩阵的列数和行数。我们在第16行和第17行调用了这2个方法。代码第21-22行中，我们运行实际上的矩阵加法，我们将返回的值赋予矩阵对象C。

我们期望这个函数几乎与通常的+运算符一样快，让我们检查一下，编译完（回忆一下，A，B为1000X1000元素的矩阵用随机函数）

        octave：13>tic(),C=madd(A，B);toc()

结果比命令2中慢5倍。

原因之一是因为读取矩阵成员用到括号运算符[]，产生了巨大成本。实际上，在C++函数按元素运行，不如实用函数和运算符，在C++库文件：举例来说，第21，22行可以调用单行来替换。

        C=A+B

如果你使用这个运算符而不是矩阵逐个元素相加，你会看到madd函数运行速度与通常octave+运算符一样快。

如果你处于一种情形，你必须逐个元素读取，你可以让一个简单的指针指向，然后读取这些，声明这个指针可以通过fortran_vec方法，在上面的矩阵加法例子重，第21，22行里可以用下面代码替换：

        const double \*Aval

**类型**

代码示例8.3显示了你如何读取和与实数矩阵工作，矩阵里每一个元素都是实数标量。如果我们试着对用madd函数2个复数矩阵相加，你将会看到只有实数部分相加在一起。然后返回，你也可以对复数矩阵相加。这里你将不得不使用ComplexMatrix类型。相应的，如果你工作于向量，你应当指定类型为行向量或者列向量。如果是复数的话，下面列出了一些最重要的类Ocave C++接口：

正如我们看到的，你可以初始化一个这些类型对象，使用许多不同方式，最常用的方法是：

最后一种初始化方法是将不会分配内存给数组元素。因此这个必须在后面分配。

SparseMatrix也可以用下面的构造函数初始化：

这里，nz为非零元素的数目，我强烈推荐你使用这个。当你预先知道非零元素的数目时，来降低内存重新分配的成本。

在代码示例8.3里，我们看到如何读取输入参数，

下面列表中总结了你可以使用的方法来读取DEFUN_DLD中的参数。

如果你希望使用Octave C++库文件和接口工作，我建议浏览一下API。发布于

**函数作为输入参数**

在第5章，我们看到如何编写Octave m函数，来调用用户级函数，你也可以在oct函数里这样做，正如m函数。你需要通过C++版的feval函数来调用：



feval第1个参数是名字（字符）指定用户提供的函数，第2个函数参数为octave_value_list类型，第3个参数做出了书目和输出数目，feval通过一个参数类型，比如生成一个2X2矩阵，来自均匀分布。

注意，我们需要包含parse.h头文件，该文件声明了feval，feval的首个参数为字符串，该函数名称为rand，为内置随机生成器，第2个函数为2，该整数全被转换成的octave_value_list或者相应的octave_value，使用octave_value(2)，第3个参数表明了rand种改变

现在我们试着更加深入，在第5章，我们编写了一个Monte Carlo积分器来求值标量函数f在区间[a,b]上的积分值。f为正数，我们做出了2个版本的积分器（1），一个循环编程函数mcintgr和更加向量化的版本，让我们试着去实现生成器，使用C++接口来看一下我们是否可以改进性能，与向量化版的文件进行比较。

正如上面所提到的，我么将努力来向量化C++代码，当我们可以找出f值所在的区间里的最大值，我们可以通过的findmax函数来实现，正如代码示例8.4与其他代码一起。

oct函数与mcintgr和mcintgr通用的方式调用，

        I=micintgr(fun,a,b,)

这里fun为用户提供的函数，a和b给出区间，mcloops为Monte-carlo循环函数里的数目。

为了节省篇幅，我只得忽略了检查和验证输入的类型，让我们先看一下DEFUN_DLD函数宏。第22-25行，我么提取了输入参数，比如说，第1个参数为字符串，包含用户提供的函数，这里应当检查参数是否真的为字符串，可以使用is_string方法，见表中列出的方法，让我们下到第32行，我们需要生成2列随机数字r1和r2，为了做到这个，我们使用Octave的内置函数rand。我们必须调用这个函数，使用2ge相应的Octave函数为rand（mclopps，1）。在我们的C++代码里，这2ge参数通过变量args（octave_value_list参数），首个元素有值mcloops，第2个参数为2。
第36行，我们调用rand函数，输入参数储存于rargs，使用通用值储存于变量tmp，最后的随机数列储存于第37行中的列向量里，第2列以同样方式产生。

第42和43行使用向量化运算符+和*。当让，我们可以在循环种运行这些数学运算，但是既然Octave会提供这个更好和更快的功能。我们会使用它，第45-51行的内容是很浅显的。

回到函数findmax，第9-11行，我们生成1个向量，在a，b区间内均匀分布，点数通过宏提供。向量化用于作为用户提供函数的参数，我们用它来找到区间的最大值，注意，我们使用ColumnVector类种max方法来计算函数输出最大值。如果我们编译代码，用mcintgr来测试，我们将会看到它没有执行得更好，这个例子说明很重要的一点，你没法优化向量化代码。

**oct文件优化**

你也许会开始想是否可以使用C++接口来优化，至少2个理由表明你会想用oct文件来进行优化。

1. 如果你需要实现一个新算法，而这个算法没有向量化过，你可以获得显著加速通过底层语言来实现算法，然后使用Octave C++接口链接至Octave解释器。你甚至可以调用库文件为你工作，此时你只需要做一个Octave接口。

2. 如果你的问题涉及用户提供函数，你可以编写这个函数通过Octave C++函数和接口，潜在地获取显著提高。

第1点在练习中加以讨论，让我们涉及问题2.

**实战时刻--重访Sikov模型**

1. 在第5章里，我们讨论如何求解一个偏微分方程使用lsode。特别的，我们使用lsode来求解Sekov模型。m函数种存在各种偏微分系统。但是我们也可以使用C++接口可以实现。回忆一下前面的函数，我们使用全局变量global_b在函数里。因此C++来实现需要从Octave工作获取这个变量。

2. 如果我们编译这个代码用mkoctfile，我们可以比较一下运行速度和m函数实现selkov，确保2个函数可以被Octave找到，比如复制Selkov到当前工作目录。

这个显示了显著的速度提升。

3. 让我们试一下不同的global_b

**刚刚发生了什么**

global_b变量调用get_global_var至函数。第6行里，该函数返回octave_value类型。我们也可以获取这个值通过调用octave_value种定义的scalar_value。

为了尽可能优化代码，我们调用x向量种的值和f，通过指针xval和fval，而不是使用（）运算符，在这个特别的例子里，几乎不会有可以预测到的性能差别。

命令18，19的输出，我们观察到加速约为6s，使得额外的努力是值得的。呢也许会认为你会等待7s。如果你会遇到1个非常大的微分方程时，你可能需要求解非常不同的参数值呢，也学你就是等上1天或6天的差别了。

命令21和22里，加速速率减至2倍。原因是因为系统进入稳定状态，在这个global_b值下，即向量x中的元素是不变的。lsode能够改变时间。如果系统是，含有关键是加速步骤。你能够从C++实现中得到的东西取决于问题的特殊性。

**前进**

在这个练习里的，会被要求实现欧拉积分器，通常，我们可以写一个通常微分方程：
$$\frac{dx}{dt}=f(x)$$

左边导数近似于一级有限元方法：

$$ $$

用公式（P。2）代入方程，重组后，我们可以得到一个更简单的微分方程

这被成为欧拉积分，该法是迭代的近似解，如果足够小的时间

1. 实现Eular的函数，语法为：

其中fun定义了方程右边的方程，$x_0$为条件初始值，dt为时间步，nsteps为步骤数目积分器可以执行。求解过程返回x，用selkov模型测试你的实现，将结果与lsode求解的结果进行比较，使用1000-10000次步骤，更改时间步的规模和时间步的书目，中什么时候会有一致性。

2. Octave C++接口种实现Eular方法，你可以将函数命名为euler，与m函数相比较。

3. 使用你自己的欧拉积分器来求解偏微分方程

比如初始条件，将其与lsode得到的结果进行比较，为什么二者之间含有一个，即然你削减了步进。
