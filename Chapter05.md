扩展：编写自定义函数

本章里，你会学习如海编写自定义函数。这将使你不仅能使用大部分Octave内置函数，还可以扩展Octave实现更多，使用更加可复用和模块化方式。

阅读完本章，你能够：

- 编写自定义函数
- 检查和验证函数用户输入参数的有效性；
- 编写函数帮助文本。
- 定义可供Octave调用的数学函数来解决微分数值问题；
- 对你自己的函数运行简单的调试。
- 向量化自定义代码。

**你的第一个自定义函数**

通常，函数的语法为：

        function [output1,output2, ...]=functionname(input1,input2,...)

          do something (body)

        endfunction

其中output1， 呕吐put，...为函数产生的输出变量，input1,input2,...为函数的输入，也被称为输入参数。函授拥有名字指定为functionname。输出中的逗号是可选的。输入和输出参数都是可选的，可以是标量，矩阵，元胞数组，文字等待。

让我们首先讨论一个简单的例子。我们的第1个函数会执行简单的任务;它会求取向量数组中的最大值和最小值。我们将函数设计成用户输入数组，函数返回最大值和最小值。回想一下，我们会用Octave中min和max函数来得到。

**实战时刻-编写minmax函数**

1. 打开编辑器，写入下面的代码：

2. 将代码保存成minmax.m，可以是当前目录或者Octave可搜索路径的任何目录。

3. 输入下面命令运行函数在Octave命令提示中。

        octave:1> a=rand(1,5)
        octave:2> [mina,maxa]= minmax(a)

  结果跟我们设想的一样。

**刚刚发生了什么**

代码示例5.1中第1行代码，我们看到函数名为minmax，x作为函数输入参数，返回输出minx和maxx。代码第3和4行很明白，endfunction关键词结束了函数体。我们采用C语言的术语“函数定义”来指函数代码，因此代码示例5.1为minmax的函数定义。

命令1里我们初始化一个含5个元素的向量数组变量a。命令2中我们将变量a作为函数的输入参数。我们使用时理解这个过程是重要的。Octave将a中的值赋值值一个函数中的数组变量x。（代码示例5.1中第1行代码）。Octave然后会运行代码中的第3行和第4行。Octave从函数得到返回值，输入命令提示行中，它将返回值赋值至变量变量minx和maxx后，然后赋值值mina和maxa。见下面图标。通过这种方式，Octave初始化一个输入和输出的局部拷贝。我们说，Octave函数采用了"按值传递"的策略。

另一个重要点再有在函数内初始化的变量（比如minx和maxx）不输入工作区的一部分。通常情况下，在函数作用域内初始化的变量会被调用域覆盖。让我们检查一下：

        octave:3> who

这些变量在命令1和2中初始化，所以是工作区域的一部分。在函数内初始化的便来能够minmax是不可见的。实际上，我们从函数中返回后，我们我们就没有几乎获取函数域内的变量。

第2章里，我们学习了setfield函数；见命令40.我们调用该函数时，我们不得不用结构体变量s作为输入和输出。我们现在可以理解为什么；设定结构体成员在函数作用域内是不会影响工作区域里变量的成员值。我们因此不得不设定好setfield内的成员后将它赋值值工作区。

文件名必须与函数名相同，比如，minmax必须用扩展名.m。在例子中，函数名和文件名不匹配，Octave可能会尝试运行文件中的函数，但是会发出警告。

**脚本与函数**

对于上面比较简单的例子，你可能会使用脚本。但是，至少3个理由选择使用函数而不是脚本：

1. 如果你尝试一个复杂问题，你的脚本经常会变得巨大，程序的流程会变得不好理解。拆分脚本成一个或者多个由几行代码组成的函数，是非常有用的。

2. 在大脚本文件中，你可能会遇到对不同对象使用相同的变量名。这很容易出错，使用函数就可以避免。

3. 你的函数可以复用来解决其他问题，因此，你就不需要将一个脚本里的部分代码复制到另一个脚本文件。这样做不仅更有效，因为将代码从一个脚本复制至另一个脚本也容易出错。

**在命令提示行中定义函数**

你也可以直接在命名提示行中定义函数。比如：

        octave:4> function [minx,maxx]=minmax(x)
        > minx=min(x);
        > maxx=max(x);
        >endfunction

同样的函数作用域规则是使用的，意味着minx和maxx仍然不是工作区的一部分，即使函数是通过命令提示行定义的。除非你在测试函数，否则你只需要一个更小的辅助函数。我推荐通过函数文件定义函数，因为更易于编辑和修改。在命令提示行中定义的函数当Octave退出时就会被删除。

**编写函数帮助文本**

函数中帮助文本（或者文档）来描述函数的用途是有用的。比如，如果你使用help plot，Octave会打印出plot函数的帮组文本，来描述其用途和用法。

编写帮助文本非常直接了当。Octave解析函数文件中的第一个注释部分作文帮助文本。即带有井号的第一行。或者百分号。下面代码里，显示如何在minmax函数中创建帮助文本：

下面命令可以生成帮助文本：

        octave:5> help minmax

注意，第11行，我们也制作了一段注释不作为帮助文本。这意味着如果删除1-7行，该注释会被当做帮助文本。这意味着帮助文本可以置于程序的任何位置，只有它在其他注释之前。

为了节省空间，我会不书写或者书写少量帮助文本，但是你可以加入所有你需要的：版本号，授权，版权，作者和更多内容。取决于你到设定，当打开文件时，编辑器可能会书写一个默认的抬头

**函数调用检查**

Octave函数可以处理多种用户输入。比如，如果用户输入文本或者矩阵数组作为输入参数？如果它将3个变量赋值给函数输出？看一下，我们这样做后会有什么状况：

        octave:6> [mina maxa]= minmax("Hello world")
        octave:7> [mina maxa]= minmax([1 2;3 4])
        octave:8> [a b c]= minmax([1 2 3 4])

命令6中，minmax函数调用文本型输入参数。这个文本被传递给max（代码示例5.2中第12行），出现一个错误。在调用max之前来捕获该错误是令人期待的。因为用户很容易混淆，如果她得到一个错误信息从max而不是从minmax这个函数调用。

命令7里，minmax调用矩阵输入参数。即使这个函数没有功能处理矩阵数组，函数返回了矩阵每列中的最小值和最大值。这当然是因为max函数和min函数是逐行工作的。但是，既然minmax最初被设计成用来应用于向量数组，我们需要处理矩阵输入。

最后，我们会收到一条通用错误信息，如果我们调用minmax3至4个输出变量。我们应该给出提示性信息，来告诉用户函数别正确调用输入或者输出参数的书目。

**usage,warning和error函数**

Octave里，你可以通过函数打印出用法和错误信息给用户：usage和warning函数。它们的最简单的形式，就是他们打印出文字信息给用户，前缀为usage：和warning：。usage函数和warning函数的区别在于usage函数强制解析器退出函数在打印出用法信息之后。但是warning函数会继续运行，在信息打印出之后。

我们可以检查minmax的输入蚕食为矩阵数组还是字符数组使用usage和warning函数来打印出合适的信息给用户：

        代码示例 5.3

        function [minx,maxx] = minmax(x)

          [nr nc]=size(x)
          if (nr>1 & nc>1)
            warning("Input to minmax is a matrix array:\
                    output will be vectors");
          elseif (ischar(x))
            usage("Input to minmax cannot be a character array")
          endif

          maxx=max(x);
          minx=min(x);

      endfunction

第3行中，我们使用内置函数size来获取输入变量的行数和列数。如果二者都大于1，变量为矩阵数组。现在，既然函数对举证工作有效，我们仅仅提醒用户输出会是向量数组而不是标量。

如果输入为字符数组，信息usage： input  cannot be a character array会输出（第8行）使用usage函数，函数停止运行。

如果不用usage函数，使用error函数，会打印出错误信息，前缀为error：，然后会停止函数。代码示例5.3中第8行，比如，可以替换成：

        error("Input to minmax cannot be a character");

当函数中某处发生未知的错误时，经常会使用error函数，当检查用户输入参数时，经常使用usage函数。

编写函数名称来打印信息是非常好的主意。你可以有一个脚本来调用许多函数，而其中只有一个失败了。如果你不在错误的信息中写出函数的名称，通过每个调用来寻找是很无趣的。

**nargin和nargout**

命令8中，minmax调用3个输入参数，导致了一个错误，报告第3个输出是未定义的。每当Octave函数被调用，变量nargin和nargout会自动生成函数的输入数目和输出数目。让我们看一个例子：

        octave:9> function fun()
        >print("Number of input : %d Number of outputs: %d \n",\ nargin, nargout")

        octave:10> fun(2,3,4)

        octave:11> [a b c]=fun()

命令11中打印出错误信息，因为它不会被赋值给返回列表中的变量。将nargin想象成“Number of ARGuments IN”，而nargout想象成“Number of ARGuments OUt”.

我们现在可以处理命令8中产生的错误了：

    代码示例5.4
    function [minx,]

第6行，我们仅仅打印出用法信息，如果nargout大于2.通过这种方法，用户允许调用minmax函数，仅仅含1个或者没有输出参数，因此只获取向量数组的最大值和最小值。我们也可以检查第3行，如果输入参数的数目是否正确，在检查输入大小是否正确，类型是否正确之前。如果我们不这样做，调用minmax函数而不带任何参数，调用size函数是无效的。Octave会打印出一个通用的错误信息而不容易被追踪。

通过这些改进，我们现在重新输入命令6-8：

    octave:10> [mina max2]=minmax("Hello World")
    octave:11> [mina,maxa]=minmax([1 2;3 4])
    octave:12> [a b c]=minmax([1 2 3 4])

命令10和12中，你可以看到用法信息（你编写的）和错误信息，打印出哪里出现错误。有时，你可以得到一大堆的错误信息，因为你调用的函数，调用了第2个函数，调用了第3个函数，该函数发生了错误。当这种情形发生时，错误信息会追溯，打印出大堆的信息至屏幕上。同，你可以通过研究第1个和最后一个错误信息就可以明白哪儿出问题了。

代码示例5.4中，主要部分是函数体，用于处理函数调用是否正确，我们没有捕获所有的错误！进行这些检查有些乏味，但是如果其他人要使用你代码时却是非常有用的。

**编写和应用用户输入函数**

第3章里，我们明白了如何来构造数学函数，通过Octave命令提示行。这里，我们会做通用的室町，但是使用Octave函数。

思考一下下面的向量值函数，我们称之为Sel'Kov函数（后面会作解释）：

$$f(x,y)=[f_1(x,y),f_2(x,y)]=[-x+0.1y+x^2y,b-0.1y-x^2y]$$

其中b为正数，我们可以变动。我们可以将方程（5.1）用一种稍微有些不同的方式，让$(x,y)=(x_1,x_2)=x$:

$$f(x)=[f_1(x_1,x_2),f_2(x_1,x_2)]=[-x_1+0.1x_2+x_1^2x_2,b-0.1x_2-x_1^2x_2]$$

当我们为方程（5.2）编写Octave函数时，我们可以用至少3种不同的方式指定b的值：

1. 我们在函数里指定b的值（在函数作用域）；
2. 我们可以将b作为函数的输入参数：
3. 我们让b为全局变量（gloabl ariable），如此，它的值可以通过工作区来获取或者在函数作用域。

第1个选项是一个不好的选择，因为我们想改变b的值时，每次我们都需要改变。正如我们后面看到的，第2选项也不是一个很好的选择，因为它会阻止我们进行函数的数值分析。因此，我们将会使用第3个选项。要想指定一个变量为全局变量，我们需要使用global词：

    代码示例5.5
    function f=selkov(x)
      global global_b;

      f(1)=-x(1)+0.1*x(2)+x(1).^2*x(2);
      f(2)=global_b-0.1x(2)-x(1).^2*x(2);
    endfunction

我们使用前缀global——来强调一个事实，变量我为全局变量，但是这个不是强制的。代码示例5.5中，global_b没有赋值，我们需要在我们调用之前设定这个值，从Octave命令提示行：

    octave:13> global global_b=12;
    octave:14> selkov([0 0])
    octave:15> global_b=23
    cotave:16> selkov([0 0])

我们可以用isglobal来检查global_b是否为全局变量：

    octave:17> isglobal("global_b")

变量也可以指定为persistent。意思是函数变量的值在函数间调用时不变的。下面的命令说明了这一点：

    octave:18> function fun()
    >persistent a=0
    >disp(a);a++;
    >endfunction

    octave:19> fun(),fun(),fun()

注意，我们将变量a设定为0，a值只是在首次赋值时为该值。我们没有使用persistent指示符，每次函数调用时变量a的值总是为0.pesistent变量可以非常方便，如果你需要每次函数调用时需要对函数进行递增。

**使用fsolve**

你也许很奇怪，什么时候全局变量会很有用。我们可以将变量b作为输入参数传递给函数。假设我们希望求解非线性方程的解（数值解）：

$$f(x)=0$$

其中，f由方程（5.2)给出。从第2章中，我们知道如何做，如果f为线性函数，但是我们没有学过如何求解如selkov函数之类的非线性解。为了找出指定点（或者说初始值）的解，我们可以使用Octave内置函数fsolve。它的最简单的形式，该函数的语法为：

    x=fsolve(fun,xguess,option)

其中fun为用户提供的函数，可以有如下的语法：

    f=fun(x)

xguess为方程（5.3）的初始值，option为结构体，包含可选的输入参数。在fun函数的输入参数中，你不能指定任何参数列表，只有自变量x，因此使用全局变量global_b比较方便。

用户定义的函数fun可以采用其他语法，我们后面会加以讨论。让我们首先使用最简单的语法。

作为例子，我们首先指定初始值，在命令中设定参数b：

    octave:21> fsolve("selkov",guess)

改变b值，我们可以得到：

    octave:22> global_b=0.6
    octave:23> fsolve("selkov",guess)

非线性方程可以有多个解。在最佳情况下，fsolve会得到单一解，这个取决于初始值。

当然，对于任意的初始值，你不能确认fsolve是否有解。如何保证初始值的“良好性”，保证fsolve会收敛至一个解，取决于函数本身。

**提供Jacobian矩阵**

为了改进收敛，你可以提供Jacoian矩阵给函数。比如Selkov函数的Jocobian矩阵为：

$$J=
\begin{bmatrix}
\frac{\partial f_1}{\partial x_1} & \frac{\partial f_1}{\partial x_2}\\
\frac{\partial f_2}{\partial x_1} & \frac{\partial f_2}{\partial x_2}
\end{bmatrix}
=
$$

其中个$f_1$和$f_2$由方程（5.2）给出，修改后的函数包括了Jacobian矩阵，如下书写：



我们需要指定fsolve函数来指定，用户自定义函数返回的Jacobian矩阵。我们可以通过可选项结构体输入参数来传递给fsolve，可以通过Octave优化结构体构造函数optimet来创建：

    octave:24> opt=optimet("Jacobian","on")

可以通过isstruct来检查opt是否为结构体。我们现在调用fsolve使用选项输入参数，生成一个随机的初始值：

    octave:25> fsolve("selkov",[0.1 -2],opt)

上面给出了方程（5.3）相同的结果，及时初始值差别很大。

**使用lsode-selkov模型的动态分析**

Sel'kov函数实际上是一部分糖酵解的模型。代谢通路中，糖和ADP会生成ATP。实际上，x1和x2分别代表该通路中F6P和ADP的浓度。糖酵解的动态Sel'Kov模型如下给出：


我们可以用向量的方式给出：

其中f(x)指方程（5.2）。方程（5.6）是自洽的常规微分方程。术语自洽试纸右边的公式中不依赖于。我们希望指导x1和x2是如何演变的（也就是说，随着时间的变化，浓度是如何改变的），我们需要求解具有初始条件的微分方程。

Octave具有强大的函数来求解微分方程的数值解。也就是方程（5.6）中的数值解。简单形式的语法为：

    f= fun(x,t)

第2个输入参数是可选的，只有微分方程系统是非自洽的才有意义。

**实战时刻--使用lsode进行数值积分**

1. 既然我有自洽系统，我们简单的使用代码示例5.5中给出的函数作为lsode函数的输入参数。首先，我们指定时间向量数值，包含0至50中的200个点：

        octave:26> global_b=1;t=linspace(0,50,200);init=[0.4 0.2];

2. 然后调用lsode函数来得到Sel'kov模型的数值积分：

        octave:27> x=lsode("selkov",init,t);

3. 现在输出变量x包含了x1和x2的解用列向量表示，意思是第一列为x1,第2列为x2.我们然后使用列向量对时间作图，比如：

        octave:28> plot(t,x(:,1),"-r","linewidth",5,t,x(:2),"-b","linewidth",5)

4. 结果在下边窗口中的左图所示，。
   如果你重复命令26-28，将global_b设定为0.6，结果就非常有意思。看窗口中右边的图形：


**刚刚发生了什么**

命令26中，我们通过全局变量global_b,定义了变量b的值。我们也可以在lsode函数内指定次数来打印出微分方程的解和初始值。命令27中，我们会使用lsode来求解Sel'kov方程。求得的解对时间来作图。注意因为微分方程有两个独立变量，我们绘制2条。

2个化合物从平稳态，不随时间而改变至一个钟摆行为。你应该通过增大时间跨度来检查这个结论。这种行为的出现是因为。

**内联函数**

Octave中，你可以定义内联函数。当我们定义简单的函数时，内联函数是非常有用的。比如：

        octave:29> f=inline("x + exp(-x)")
        octave:30> f(0)

不可能做更多的事情来对内联函数进行验证和检查，我在本书里就没有使用这种函数。

**高级函数编程：Monte Carlo积分**

许多科学问题涉及积分的计算。如果f为单变量函数标量，并且可积，我们可以将积分表示成：

其中F(x)为f函数的反导数。分析法计算大部分函数的积分是令人恐怖的，并且是不可能的任务，这就是我们改用数值法的原因。

存在多种方法计算积分。这里我们使用Monte Carlo方法编写函数。最后，我们会讨论Octave里的其他积分计算方法。现在，假设f为区间里为正值，最大值为M。我们可以构成一个矩形，面积为。下图说明。这里，点随机分布于矩形中，其中b=2,a=0.5,M=0.4356.蓝色的曲线代表函数f的图形。

如果我们随机地将点分散至矩形中，f函数图形下点比例与整个面积的比值。意味着积分的近似值为：

其中N为图形下面的点，N为整个矩阵中的点数。

使用下面的程序流程图来实现上面的想法是相对比较容易的，条件中包括等号，比如, 而不是。但是，我们既然使用Octave的rand函数，终点就不包括在区间里。

从流程图，我们可以看到，我们需要生成随机数，我们可以使用Octave中的rand函数从0至1之间的均匀分布来取出随机数。

流程图建议使用下面的语法来调用mcintgr:

        I=mcintgr(fun,a,b,mcloops)

其中I为积分的计算值，fun为用户定义函数，a和b为区间，mcloops为Monte Carlo循环数，在进行编写积分器之前，我们需要对一些事情进行说明。

**feval函数**

当我们需要编写Octave函数需要调用自定义函数，我们必须用Octave中feval函授来调用。正如上面说过，Octave函数是通过按值传递。这意味着当你需要传递函数是，需要将函数名而不是函数复制至运行的函数中。

feval的语法为：

        [output1,output2,...]=feval(function name, input1,input2,...)

其中output1,putput2,...为函数输出值，function name为函数名，input1,input2,...为该函数的输入参数。feval函数也可以从命令提示行中输入，因此使用feval来调用minmax函数来对此进行说明：

        octave:31> [mina maxa]=feval("minmax",rand(10,1))

这里feval函数调用minmax，近含有一个输入参数，即，随机数向量。minmax的输出通过feval函数返回给用户。

你也可以不在命令提示行或者脚本中使用feval函数，只有当你需要在函数作用域中调用用户定义函数，

你也可以让函数接收所谓函数句柄来作为输入参数，而不是函数名，但是我们这里只采用更为传统的方式来调用用户定义方式。如果你想了解更多有关函数句柄的内容，查阅一下Octave手册。

**验证用户定义函数**

这里还有2个问题需要解决，首先，如果用户传递的函数不存在？这个问题可以使用exist函数来解决。该函数接收文字作为输入参数，返回一个非零值，如果存在一个该字符描述的变量，函数，文件或者目录。返回值准确地告知该字符串相关联的是什么。不幸的是，在当前版本（Octave 3.2.4）,exist函数在windows中不能区别变量名和用户定义函数名，因此为了保持兼容性，我们只是检查exist函数是否返回非零值。

其次，我们应当检查函数是否返回标量，以及是否为正，既然我们的算法只是计算区间里正数部分。幸运的是，我们可以使用已经学过的min和length函数来检查。我们现在可以编写Monte Carlo积分器了，再一次，为了节省空间，我们省略了帮助文本。


同minmax函数一样，函数代码的主要部分主要是在处理输入参数：还有更多部分需要检查，比如，如果b小于a，如果它们都是标量，实际上Monte Carlo的代码只有9行。

有3点值得关注，21-24行中if语句检查了如果韩式在只当的区间里为正直。使用100个区间里偶数分布的数字。如果函数快速变化，如果区间跨度很大，这个检查是不够的。我们使用symbolI作为积分。不全是，因为I只是作为函数作用域里的变量，对工作区变量是没有影响的。最后，因为数值的方法基于随机数，积分的数值会每次函数调用都会不一样，及时使用同样的积分。对于不确定性的结果做平均值是个好主意。第7章里，我们Octave里看到这是如何实现的。

现在测试一下函数。使用已知结果的问题来测试是个好想法，比如，正弦函数在[0:]里的积分为：

$$I=\int_{0}$$

使用mcintgr使用Monte Carlo循环，我们会得到：

使用10000个Monte Carlo循环。

这个对于积分的更好的近似。我们也可以在文件直接定义自己的函数，使用Monte Carlo积分器来计算积分:

这个积分直接手工计算是很难的。

我们也需要对用户接口进行检查，使用信息更我们想象一致打印。首先，让我们输入非法函数名称：

来看一下我们是否可以检查标量函数，我们首先定义一个向量值函数，比如：

      octave：37>

让我们调用mcintgr时使用该函数：

最后，我们将生成负值的函数进行积分：

情况跟我们预期一样工作。

**使用quad和trapz进行数值积分**

Octave的内置函数quad可以运行跟mcintgr的积分工作。函数以算法命名，即。简单的形式，quad函数可以如下调用：

        octave:41> quad("sin",0,pi)

其中“sin”为Octave中的正弦函数，0和pi分别是下限和上限。这人你看到的，quad函数是非常准确的，也许你还注意到，它运行得非常快速。使用help quad可以看到所有quad函数的可能用法。

有时，你没有一个良好定义的数学函数，而是从文件中得到的一系列数据点。这种情况下，你可以使用trapz函数，使用trapezoidal法则来对数据进行积分。这个算法步入quadrature算法精确。为了说明trapz函数，让我们首先生成一个正弦函数的数据组，将它作为trapz函数的输入参数：

        octave:42> x=linspace(0,pi);y=sin(x);
        octave:43> trapz(x,y)

只是使用了100个数据点，trapz函数得到的结果与quad函数相比不够准确。但是你可以通过增加数据点来得到一个更好的结果。

最后的注意点：你可能很疑惑，为什么会有人想用Monte Carlo方法。很明显，速度较慢又不够准确。我们只是这里只是处理了单变量函数。在多变量函数中，我们，该方法与相比会有优势，特别是在高维度时。

**向量化编程**

代码示例5.7中的Monte Carlo方法像C语言或者其他低级编程语言一样在编写。这不是Octave我们做事情的方式！正如你所知的，Octave是向量化的语言，被设计用来操作数组。比如，我们随2个向量进行相加，我们会使用：

        c=a+b;

而不是：

        for n=1:length(a)
          c(n)=a(n)+b(n);
        endfor

Octave中使用选项1的理由有3个：

1. 代码运行更快速。第8章里，我们可以看到如何测量运行速度，研究向量化代码能有多快。
2. 需要编写的代码行数可以显著减少，也减少潜在的编码错误。
3. 任何维度不匹配可以被Octave解释器轻易检查出来，然后打印出有意义的错误信息。

Monto Carlo循环包括生成一系列随机数，然后将随机数与函数值进行比较。除了用循环来实现这些操作以外，我们可以同时生成所有的随机数，找到相应的函数值，然后对数组进行比较操作。

**实战时刻--向量化Monte Carlo积分器**

采用上面方法，mcintgr函数的向量化版本为：

        代码示例5.8
        function I=mcintgrv(fun,a,b,mcloops)

**刚刚发生了什么**

向量化的函数与mcingr函数具有相同的输入参数和输出。代码很直截了当，很容易理解，也学除了第19行代码。这里我们首先运行函数值和随机点的比较操作。比较操作得到了一个布尔数组，然后传递给find函数，返回矩阵中为真值元素的索引。使用length函数得到索引的个数，我们只需要计算曲线下的点数。

在我的机器上，向量化的Monte Carlo积分器运行比“常规”方法快了300倍。使用向量化编程，你也可以避免循环来运行微小任务。实际上，一旦你适应了，向量化后的代码更容易阅读，错误也更容易找到。因此，经常考虑一下向量化自己代码的可行性。

只要有可能，脚本也应向量化。

**简单调试**

早期的Octave版本，你不得不通过加入printf函数和disp函数调用，来查找自己代码中的bug。这样做很烦人，因为你会发现断言函数只是找到了打字错误，却污染了代码。Octave现在带有一个简单但是非常有用的调试器。调试器这种基本工具，让你监视，甚至一定程度上控制函数内的变量。这些变量通常不会出现在工作区，即用户可以方便查找出什么地方，什么变量发生了错误。

代码示例5.9展示了修改过的代码示例5.8.只是改动了一行代码，函数现在什么都不会生成。比如：

        octave:44> mcintgrdb("sin",0,pi,1000)

我们知道结果是不对的。

我们不要通过逐行比较两个函数代码来找出代码中的问题。而是采用调试器。

首先，我们需要指示调试器在代码的某处停止运行。我们做完这个后，我们在代码中步进，我们可以监视每个变量的值。我们现在还没有线索来显示出错之处，所以我们应当启动我们的监视器。使用dbstop函数，我们可以做到这点：

        octave:45> dbstop("mcintgrdb",1)

dbstop函数的第一个输入参数为函数名，第2个为我们相容Octave解释器停止运行的代码行号。这又称为断点。现在，代码第1行，没有命令，只是函数名，输入参数和输出参数的声明。dbstop函数足够智能，知道改行，会在第3行停止运行，即首行命令。这个信息会通过输出来告诉你。

dbstop函数不会为你调用函数，因此，我们需要自己去做：

        octave:46> mcintgrdb("sin",0,pi,1000)

正如你所看到的，Octave会在mcintgrdb函数的第3行停止运行。如果我们进入调试模式，你会看到调试提示行：

        debug>

该提示行的工作方式与Octave提示行一样，但是你现在可以函数作用里读取变量信息：

        debug> b

意味着变量b的赋值为。你甚至可以给出命令，将值赋值给变量。比如：

        debug> c=sin(b)

该命令初始化一个变量c，其值接近于0.

让我们步进代码。往下移一行至第4行，我们运行：

        debug> dbnext

我们现在处于第4行代码。通过这种方式，我们逐行查读代码，检查变量的值是否跟预期一样。如果你确定某部分代码没有bug，你并不需要每行步进，简单地跳过后面的代码，比如说6行：

        debug> dbnext 6

我们现在知道变量x为随机数组，元素取值在。我们可以检查一下：

        debug> min(x)

因此，这里有什么东西不对。x在变量a，l和r1中，我们检查这些变量的值：

        debug> a
        debug> l
        debug> r1

这个结果不正确，意味l应该为。

离开调试模式，输入：

       debug> dbquit

你会返回至Octave命令提示行（也不能访问函数作用域内的变量）。如果我们调用mcintgrdb函数，我们会重新进入调试模式，因为我们并没有清除或者删除断点。要想这样，我们调用dbclear:

      debug> dbclear

我们可以设定多个断点使用dbstop，然后使用dbcont命令直接跳至下个断点，而不是我们上面的逐行步进。如果没有断点，函数会正常运行，完成后退出断点。

**多函数文件**

我们上面在一个文件里定义一个函数。函数文件名必须与函数一样，扩展名为.m。单一文件里是可以定义多个函数。如果你需要减少文件数量时是非常有用的做法。魔法在于让Octave对待脚本一样对待函数，避免在函数开始使用关键词function。
