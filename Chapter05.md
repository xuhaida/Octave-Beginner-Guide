扩展：编写自定义函数

本章里，你会学习如海编写自定义函数。这将使你不仅能使用大部分Octave内置函数，还可以扩展Octave实现更多，使用更加可复用和模块化方式。

阅读完本章，你能够：

- 编写自定义函数
- 检查和验证函数用户输入参数的有效性；
- 编写函数帮助文本。
- 定义可供Octave调用的数学函数来解决微分数值问题；
- 对你自己的函数运行简单的调试。
- 向量化自定义代码。

**你的第一个自定义函数**

通常，函数的语法为：

        function [output1,output2, ...]=functionname(input1,input2,...)

          do something (body)

        endfunction

其中output1， 呕吐put，...为函数产生的输出变量，input1,input2,...为函数的输入，也被称为输入参数。函授拥有名字指定为functionname。输出中的逗号是可选的。输入和输出参数都是可选的，可以是标量，矩阵，元胞数组，文字等待。

让我们首先讨论一个简单的例子。我们的第1个函数会执行简单的任务;它会求取向量数组中的最大值和最小值。我们将函数设计成用户输入数组，函数返回最大值和最小值。回想一下，我们会用Octave中min和max函数来得到。

**实战时刻-编写minmax函数**

1. 打开编辑器，写入下面的代码：

2. 将代码保存成minmax.m，可以是当前目录或者Octave可搜索路径的任何目录。

3. 输入下面命令运行函数在Octave命令提示中。

        octave:1> a=rand(1,5)
        octave:2> [mina,maxa]= minmax(a)

  结果跟我们设想的一样。

**刚刚发生了什么**

代码示例5.1中第1行代码，我们看到函数名为minmax，x作为函数输入参数，返回输出minx和maxx。代码第3和4行很明白，endfunction关键词结束了函数体。我们采用C语言的术语“函数定义”来指函数代码，因此代码示例5.1为minmax的函数定义。

命令1里我们初始化一个含5个元素的向量数组变量a。命令2中我们将变量a作为函数的输入参数。我们使用时理解这个过程是重要的。Octave将a中的值赋值值一个函数中的数组变量x。（代码示例5.1中第1行代码）。Octave然后会运行代码中的第3行和第4行。Octave从函数得到返回值，输入命令提示行中，它将返回值赋值至变量变量minx和maxx后，然后赋值值mina和maxa。见下面图标。通过这种方式，Octave初始化一个输入和输出的局部拷贝。我们说，Octave函数采用了"按值传递"的策略。

另一个重要点再有在函数内初始化的变量（比如minx和maxx）不输入工作区的一部分。通常情况下，在函数作用域内初始化的变量会被调用域覆盖。让我们检查一下：

        octave:3> who

这些变量在命令1和2中初始化，所以是工作区域的一部分。在函数内初始化的便来能够minmax是不可见的。实际上，我们从函数中返回后，我们我们就没有几乎获取函数域内的变量。

第2章里，我们学习了setfield函数；见命令40.我们调用该函数时，我们不得不用结构体变量s作为输入和输出。我们现在可以理解为什么；设定结构体成员在函数作用域内是不会影响工作区域里变量的成员值。我们因此不得不设定好setfield内的成员后将它赋值值工作区。

文件名必须与函数名相同，比如，minmax必须用扩展名.m。在例子中，函数名和文件名不匹配，Octave可能会尝试运行文件中的函数，但是会发出警告。

**脚本与函数**

对于上面比较简单的例子，你可能会使用脚本。但是，至少3个理由选择使用函数而不是脚本：

1. 如果你尝试一个复杂问题，你的脚本经常会变得巨大，程序的流程会变得不好理解。拆分脚本成一个或者多个由几行代码组成的函数，是非常有用的。

2. 在大脚本文件中，你可能会遇到对不同对象使用相同的变量名。这很容易出错，使用函数就可以避免。

3. 你的函数可以复用来解决其他问题，因此，你就不需要将一个脚本里的部分代码复制到另一个脚本文件。这样做不仅更有效，因为将代码从一个脚本复制至另一个脚本也容易出错。

**在命令提示行中定义函数**

你也可以直接在命名提示行中定义函数。比如：

        octave:4> function [minx,maxx]=minmax(x)
        > minx=min(x);
        > maxx=max(x);
        >endfunction

同样的函数作用域规则是使用的，意味着minx和maxx仍然不是工作区的一部分，即使函数是通过命令提示行定义的。除非你在测试函数，否则你只需要一个更小的辅助函数。我推荐通过函数文件定义函数，因为更易于编辑和修改。在命令提示行中定义的函数当Octave退出时就会被删除。

**编写函数帮助文本**

函数中帮助文本（或者文档）来描述函数的用途是有用的。比如，如果你使用help plot，Octave会打印出plot函数的帮组文本，来描述其用途和用法。

编写帮助文本非常直接了当。Octave解析函数文件中的第一个注释部分作文帮助文本。即带有井号的第一行。或者百分号。下面代码里，显示如何在minmax函数中创建帮助文本：

下面命令可以生成帮助文本：

        octave:5> help minmax

注意，第11行，我们也制作了一段注释不作为帮助文本。这意味着如果删除1-7行，该注释会被当做帮助文本。这意味着帮助文本可以置于程序的任何位置，只有它在其他注释之前。

为了节省空间，我会不书写或者书写少量帮助文本，但是你可以加入所有你需要的：版本号，授权，版权，作者和更多内容。取决于你到设定，当打开文件时，编辑器可能会书写一个默认的抬头

**函数调用检查**

Octave函数可以处理多种用户输入。比如，如果用户输入文本或者矩阵数组作为输入参数？如果它将3个变量赋值给函数输出？看一下，我们这样做后会有什么状况：

        octave:6> [mina maxa]= minmax("Hello world")
        octave:7> [mina maxa]= minmax([1 2;3 4])
        octave:8> [a b c]= minmax([1 2 3 4])

命令6中，minmax函数调用文本型输入参数。这个文本被传递给max（代码示例5.2中第12行），出现一个错误。在调用max之前来捕获该错误是令人期待的。因为用户很容易混淆，如果她得到一个错误信息从max而不是从minmax这个函数调用。

命令7里，minmax调用矩阵输入参数。即使这个函数没有功能处理矩阵数组，函数返回了矩阵每列中的最小值和最大值。这当然是因为max函数和min函数是逐行工作的。但是，既然minmax最初被设计成用来应用于向量数组，我们需要处理矩阵输入。

最后，我们会收到一条通用错误信息，如果我们调用minmax3至4个输出变量。我们应该给出提示性信息，来告诉用户函数别正确调用输入或者输出参数的书目。

**usage,warning和error函数**

Octave里，你可以通过函数打印出用法和错误信息给用户：usage和warning函数。它们的最简单的形式，就是他们打印出文字信息给用户，前缀为usage：和warning：。usage函数和warning函数的区别在于usage函数强制解析器退出函数在打印出用法信息之后。但是warning函数会继续运行，在信息打印出之后。

我们可以检查minmax的输入蚕食为矩阵数组还是字符数组使用usage和warning函数来打印出合适的信息给用户：

        代码示例 5.3

        function [minx,maxx] = minmax(x)

          [nr nc]=size(x)
          if (nr>1 & nc>1)
            warning("Input to minmax is a matrix array:\
                    output will be vectors");
          elseif (ischar(x))
            usage("Input to minmax cannot be a character array")
          endif

          maxx=max(x);
          minx=min(x);

      endfunction

第3行中，我们使用内置函数size来获取输入变量的行数和列数。如果二者都大于1，变量为矩阵数组。现在，既然函数对举证工作有效，我们仅仅提醒用户输出会是向量数组而不是标量。

如果输入为字符数组，信息usage： input  cannot be a character array会输出（第8行）使用usage函数，函数停止运行。

如果不用usage函数，使用error函数，会打印出错误信息，前缀为error：，然后会停止函数。代码示例5.3中第8行，比如，可以替换成：

        error("Input to minmax cannot be a character");

当函数中某处发生未知的错误时，经常会使用error函数，当检查用户输入参数时，经常使用usage函数。

编写函数名称来打印信息是非常好的主意。你可以有一个脚本来调用许多函数，而其中只有一个失败了。如果你不在错误的信息中写出函数的名称，通过每个调用来寻找是很无趣的。

**nargin和nargout**

命令8中，minmax调用3个输入参数，导致了一个错误，报告第3个输出是未定义的。每当Octave函数被调用，变量nargin和nargout会自动生成函数的输入数目和输出数目。让我们看一个例子：

        octave:9> function fun()
        >print("Number of input : %d Number of outputs: %d \n",\ nargin, nargout")

        octave:10> fun(2,3,4)

        octave:11> [a b c]=fun()

命令11中打印出错误信息，因为它不会被赋值给返回列表中的变量。将nargin想象成“Number of ARGuments IN”，而nargout想象成“Number of ARGuments OUt”.

我们现在可以处理命令8中产生的错误了：

    代码示例5.4
    function [minx,]

第6行，我们仅仅打印出用法信息，如果nargout大于2.通过这种方法，用户允许调用minmax函数，仅仅含1个或者没有输出参数，因此只获取向量数组的最大值和最小值。我们也可以检查第3行，如果输入参数的数目是否正确，在检查输入大小是否正确，类型是否正确之前。如果我们不这样做，调用minmax函数而不带任何参数，调用size函数是无效的。Octave会打印出一个通用的错误信息而不容易被追踪。

通过这些改进，我们现在重新输入命令6-8：

    octave:10> [mina max2]=minmax("Hello World")
    octave:11> [mina,maxa]=minmax([1 2;3 4])
    octave:12> [a b c]=minmax([1 2 3 4])
