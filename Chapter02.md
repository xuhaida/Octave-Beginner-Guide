Octave被设计成与向量和矩阵工作。在这章里你会学会如何初始化对象（或者变量），如何比较它们，如何执行简单的算法运算。Octave也支持更多高级的即变量类型。即结构体和元胞数组。通过Octave你会学会，你会有一个函数武器哭，使你返回变量的信息。这些工具是很重要的，在本书后面。我们会学会重要的内容。

详细地说，我们会学到：

- 初始化简单的数值型变量，比如标量，向量和矩阵；
- 初始化文本字符变量；
- 初始化复数变量；
- 获取变量成员，通过向量化方式；
- 初始化结构体，元胞和多维数组；
- 获取变量信息；
- 数值变量加减运算；
- 执行矩阵乘法；
- 求解线性方程系统；
- 比较变量；

**简单的数值变量**

在后面，我们会看到如何初始化简单的变量。通过简单的变量，我们意思是表来标量，向量和矩阵。首先，标量变量具有名称，变量a通过命令赋值为1：

        octave: 1> a=1;

即你命名变量名称，本来中为a，然后你使用等号来将一个值来赋值给变量。注意，Octave种，变量不用指点个类型来初始化，正如C和其他底层语言。Octave将数字解释成实数，除非你显示地告诉它。

让我们向前走，初始化数值数组：

Octave解释成行向量：

$$b=
    \begin{bmatrix}
      1 & 2 & 3
    \end{bmatrix}
$$

而不是简单的一维数组，强制元素可以用逗号分开，因此前面命令也可以是，初始化列向量：

你可以使用：

注意，每个元素用分号分开。

现在我们往前走，初始化一个矩阵2行3列:

$$A=
        \begin{bmatrix}
        1 & 2 & 3 \\
        4 & 5 & 6
        \end{bmatrix}
$$

使用下面的命令

注意，我使用大写字母来命名矩阵，使用小写字母来命名标量和向量。当然，这只是个人的爱好。Octave在这个方面没有强制规定。重要的是，Octave里大写字母和小写字母是敏感的。如果我们在命令5种小写字母，Octave会覆盖已有的变量名。每当我们对一个已经存在的变量名重新命名时，旧的赋值不再可以进入，因此重新赋值时要非常小心。

本书里我们将会使用更多通用的数组来指定向量或者矩阵变量。

**读取和改变数组成员**

进入 行向量b中的第2个元素，我们使用括号：

        octave:6 >b(2)
        ans = 2

也就是，数组索引从1开始，我们看到ans的反应。但是没有做出解释。这是“答案（answer）”的缩写，是具有值的变量。上面例子中的值为2。

对于矩阵变量A，我使用，比如说：

        octave:7> A(2,3)
        ans= 6

想进入第2行第3列的元素。我们也可以用冒号来读取整行和整列数据。

        octave:8 >A(:,2)
        ans =
          2
          5

现在我们知道如何读取向量和矩阵中的元素。我们也可以改变这些元素的值，尝试将元素A（2，3）设定为-10.1：

        octave:10 > A92,3)=-10.1

        A=
          1.0000   2.0000 3.0000
          4.0000   5.0000 -10.1000

因为A中的一个元素为非整数数值，现在所有元素按照浮点格式显示，显示的数字位数依赖于默认的设置。但是，对于Octave解释器没有不同，总是使用双精度，除非你明确要求使用不同精度。

也可以通过整行通过分号操作符来改变整行的元素。要提换掉矩阵A中整个第2行，我们使用：


这种替换是有效的，因为向量b与A中的行元素数目相同哦，让我们故意将事情弄乱，将A种的第2列用向量b来替换：

这里，Octave打印出错误信息告诉我们说，维数不匹配，因为我们想用3个元素来替换掉数值中的2个元素，并且b是一个3个元素的向量，我们不能用行来换列。

这里有一个例外的情况，你可以用标量来替换掉一整列或者一整行的数据。

**更多例子**

除此之外，删除元素，整列和整行，扩展函数

**实战时刻-数组操作**

**刚刚发生了什么**

命令14中，Octave将[]解析成为空的列向量，A中第2列在命令中被删除。不是删除，我们删除一列。命令15中，等号右边，我们通过[b 4 5]构建了一个新向量，即如果我们写出b，我们会得到[1 2 3 4 5]。既然b=[1 2 3]。因为等号，我们将该向量赋值给b，而删除了已经存在的b值。当然，我们不能扩展b，使用b=[b;4;5]。既然通过增加一个行向量的列向量。命令16，我们初始化一个行向量7。命令17，我通过使用元素索引1，3，5，7和9.即命令18需要，d为含10个元素的行向量，但是这里，Octave自己延长向量，将加入的元素设置成0。如果你指定数值。命令18里，我们只能将Octave设定元素12为-1，元素11因此被设定为默认值0，从输出可以看到，在底层编程语言，或未分配的数组会导致系统崩溃。

**复数变量**

Octave也支持复数计算，正如你看到的，复数可以写成z=a+bi,a为实数部分，b为虚数部分，i为虚数单位，即定义$i^2=-1$。

初始化复数变量，比如说z=1+2i,你可以输入：

Octave开启时，变量i，j，I和J都是虚数单位，都可以使用。我倾向于用I来表示虚数单位，因为i和j经常被用来作为循环中的变量，而I不像i常用。

为读取复数的实数和虚数部分，你使用：

        octave:20> real(s)
        ans=1
        octave:21> imag(s)
        ans=2

你也可以初始化复数向量和复数矩阵，比如：

        octave:22> Z=[1 -2.3I;4I 5+6.7I]
        Z=
          1.0000+0.0000i   0.0000-2.3000i
          0.0000+4.0000i   5.0000+6.7000i

注意！如果数组元素中有非零实数和虚数部分，在两部分之间必需留有空白。比如，命令22里我们使用Z=[1 -2.3I;4I 5 + 6.7I]最后的元素会被解析成两部分（5和6.7I)。这将导致维数不匹配的错误。

复数数组中的元素可以通过实数数组同样的方法读取。你可以使用real(Z)和imag(Z)来打印复数数组Z中实数和虚数的部分。

**文本变量**

尽管Octave主要是计算工具，你也可以处理文本变量。后面的章节里，你会看到为什么这是非常方便的。字母（或者字符），单词，句子，段落，等待，都可以命名为文本字符串。

初始化文本字符，你可以：

        octave:23>t="Hello"
        t=Hello

除了双引号，你也可以使用单引号。我倾向于字符中使用双引号。因为与大部分其他编程语言遵循的语法一致，与我们在本章节后面后面学到的转置运算符通常不一致。

你可以将文本字符视为字符数组，就像向量为数值型数组一样。要读取文本中的字符，你可以简单地写下:

        octave:24> t(2)
        ans=e
        octave:25> t(2:4)
        ans=ell

就像我们对待数值数组一样。我们也可以扩展现有的文本（注意双引号后面的第一个字符空白字符）

        octave:26 t=[t " World"]
        t= Hello World

你也可以如下所示使用文本元素初始化一个变量：

        octave:27> T= ["Hello";"George"]
        T=
          Hello
          George

字符串变量T的表现很像字符矩阵（二维数组）。现在你可以像读取数值矩阵元素一样读取字符：

        octave:28> T(2,1)
        ans=G

但是等等。字符“hello”中的字符数为5，而字符”George”有6个字符。Octave不是应当发出警告来投诉字符数不一致吗？答案是否定的。两个字符串长度不一致的情形下，Octave只是简单地将空白字符加至字符串后面。在上面的例子中，字符串“Hello”被转变成“Hello ”。强调一下，这只对字符串有效。

命令：

        octave:29>A=[1 2; 3 4 5]
        error: number of columns must match (3 !=2)

导致一个错误，清除地表明问题所在。

**高维数组**

Octave也支持高维数组。这些也可以像其他数组一样初始化，比如：

        octave:30> B(2,2,2)=1
        B=
        ans(:,:,1)=
          0     0
          0     0
        ans(:,:,2)=
          0     0
          0     1

上面的命令初始化一个3维数组B,大小为2x2x2，即，$2^3=8$个元素，将元素B（2，2，2）赋值为1。回想一下，Octave会将所有未指定的元素赋值为0。Octave显示3维数组成2个2维数组。我们现在可以读取所有单个元素和将我们想要的值赋给它们：

        octave:30> B(1,2,1)=42
        B=
          ans(:,:,1)=
            0     42
            0     0
          ans(:,:,2)=
            0     0
            0     1

**测试-使用数组工作**

1. 下面哪些变量初始化是无效的：

**结构体和元胞数组**

许多真实应用中。我们必须处理许多不同类型变量的对象。比如，我们希望描述弹射体的运动，预先知道质量（标量），瞬时速度（向量），类型（字符串）等等是有用的。Octave里，你可以初始化一个变量，包含了所有这些信息。这些变量被称为结构体和元胞数组。

**结构体**

Octave中的结构体与C相似，拥有名称，比如弹射体，和一系列成员，拥有名称，正如下面图形所示：

我们可以指向单个结构成员使用.字符：

        structurename.fieldname

这里structurename为结构体变量的名称，fieldname为成员名称。

这里我们展示了结构体的例子，我们使用上面描述的弹射体。让我们命名一个结构体变量projectile，将成员名称设定为mass，elocity和type。你当然也可以选择其他的名称。

**实战时刻--初始化结构体**

1. 设定弹射体的重量，我们使用

        octave:32>projectile.mass=10.1
        projectile=
        {
          mass=10.100
        }

2. 以类似方式设定速率：

        octave:33>projectile.velocity=[1 0 0]

3. 我们也用同样的方法设定文本：

        octave:34>projectile.type="Cannonball"

还有位置，还有其他相关的。

**刚刚发生了什么**

命令32初始化了一个结构体变量projectile，命名了mass的成员变量，值为10.100.这时，结构体变量还只是拥有一个成员。

命令33和34，我们然后增加了两个成员至结构体变量，分别命名为elocity和type，当然，还可以增加更多的成员至结构体变量中。

除了一次输入一个结构体成员外，你也可以使用struct函数。（下一章里，我们会学习Octave中的函数实际是什么）：

        octave:35> projectile=struct("mass",10.1,"velocity",[1 0 0],"type","Cannonball");

struct函数的输入（也被称为参数）是一个结构体成员接着它的值，一个结构体成员接着它的值等待。实际上，说到结构体第1个成员，第2个成员是没有意义的，你可以改变struct函数输入参数的顺序而不会有不好的影响。

你注意到了吗，在命令的最后使用了分号来阻止反应（输出）？

**读取结构体成员**

你可以读取和改变结构体体种的各个成员，比如：

        octave:36>projectile.velocity(2)=-0.1

当你有很多的，拥有弹射体结构体数组是很实用的。初始化2个这样的弹射体结构体，你简单地将整个弹射体结构体复制至每个数组成员里：

        octave:37> s(1)=projectile;
        octave:38> s(2)=projectile;

注意，使用等号将结构体复制，你就可以不用将成员逐个复制了。读取结构体种的成员，你可以：

        octave:39> s(2).type
        ans=Cannonball

octave有2个函数，一个用来设定结构体成员，一个用来读取它们。这些函数分别为setfield和getfield：

        octave:40> s(2)=setfield(s(2),"type","Cartridge");
        octave:41> getfield(s(2),"type")
        ans=Cartridge

你必须从setfield将输出值结构体。为什么会这样将会在第5章里加以解释。上面例子只是显示了如何初始化一个一维结构体数组，但是你愿意的话，你也可以处理多维数组。

你可以初始化套嵌结构体，即它的一个或者多个成员可以也是结构体。让我们通过基本的弹射体结构体哦来加以说明：

       octave:42> projectiles=struct("type1",s(1),"type2",s(2));
       octave:43> projectiles.type1.type1
       ans=Cartridge

这里projectiles含有两个成员，分别为type1和type2。他们都是一个结构体，分别为s（1）和s（2）。

正如你可以想象地到的，扩展后的结构体的复杂性和多样性可以变得非常巨大，我们就到这里为止了。

**元胞数组**

Octave里，你可以处理元胞数组。元胞数组是指一个数据容器样的结构，可以同时含有数值和文本变量，但是与结构体不一样，它不含有成员。元胞数组里的每个格子（或者元素）可以是标量，向量，文本等等。我喜欢将元胞数组想象成一个格子数组，就像电子表格那样，如下所示；

**实战时刻--初始化元胞数组**

1. 使用projectile结构体初始化一个元胞数组，我们可以使用：

        octave:44> projectile={10.1,[1 0 0],"Cannonball"}

方括号里的数字为行索引和列数索引。

2. 读取一个单元，你必须使用大括号：

        octave:45> projectile{2}

3. 你也可以使用二维元胞数组。比如：

        octave:46> projectiles={10,1,[1 0 0],"Cannonball";1.0,[0 0 0],"Cartridge"}

4. 要读取储存于元胞数组里的值，简单地使用：

        octave:47> projectiles{2,3}
        ans=Cartridge

**刚刚发生了什么**

命令44使用1行3列的数据初始化了一个元胞数组。第1个单元里包含了重量，第2个单元里为速率，第3个单元为文本“Cannonball”，与我们上面讨论的结构体类似。注意，数组单元包含了不同的变量类型，元胞数组因此与通常的数组是不同的。

要读取单元里的数值，你可以使用大括号，而不是通常的括号，正如命令45中显示的。

你也可以处理二维元胞数组。命令46和47显示了一个例子。注意，插入一个更多的行至元胞数组，你需要像数值数组一样使用冒号。

**向前--处理结构体**

初始化变量名train，包含有下面的成员名称和值：

使用setfield函数来改变重量为90.0.将第2个元素wagon_index_array为23。

**获取信息**

在本节列，我们学会了如何得到已经初始化后变量的信息，这个特别有用，当你忘记了名称，大小，当你从文件中载入数据是（第4章里有更加详细的说明）。

**实战时刻--使用whos**

我们处理了许多变量，我们可以用whos将他们列出：

        octave:48> whos

**刚刚发生了什么**
