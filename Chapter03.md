正如我们承诺的那样。我们会在后卖弄更详细地讨论Octave函数。本章的第1部分就设计这个，对于Octave提供的最有用的函数做一个入门和介绍。在第2部分，我们会看一下如何用Octave函数绘制二维和三维作图。

特别地，我们会覆盖：

- 基本数学函数；
- 辅助函数用于初始话变量原书进行简单的变量分析；
- 线性代数和多项式函数。

后半部分，我们带你看一下作图框架，你会学到：

- 如何做二维和三维的图；
- 关于；
- 如何改变图标和图表窗口的性质。

**Octave函数**

你可以将Octave函数视为通常的数学函数，它使用输入，做一些工作，然后返回输出。比如，第2章里的命令20，我们使用了real函数。我们赋给复数标量输入变量，返回z的实数部分。

Octave函数通常可以接受多个输入（也被称为参数或者输入参数），返回多个输入参数。函数的通常语法为：

        [output1,output2,...]= function name(input 1,input 2, ...)

函数的输入和输出可以是标量，多维数组，结构体等等。注意，输出可以用逗号分开。因为Octave不需要与类型指示进行操作。函数应可以处理所有类型的输入，不是执行不同的操作（因此也会返回不同的输出，就是报告错误。有时，我们会使用函数接口，而不是函数语法，但是它们指的是同一件事。

我喜欢将函数分为3类：

1. 数学函数（比如，指数函数和三角函数）。
2. 辅助函数（比如，real函数）。
3. 操作函数（比如，inv函数）

Octave里，当然没有分类。希望，某种意义上说，它们都是辅助函数。但是，这有助于我们理解这些函数之间的差别。也许说明如何使用Octave函数的方法是通过数学函数，因此，让我们从它们开始。

**数学函数**

Octave提供了你所有有用的初级数学函数。让我们看一些例子。

**实战时刻--使用cos函数**

1. 为了计算一个数，比如书$\pi$的正弦值，我们可以简单地输入：

        octave:1>cos(pi)

2. 如果我们输入一个向量呢？是的，为什么不试试呢。我们知道如何初始化向量：

        octave:2> x=[0:pi/2:2*pi]

  x的正弦值：

        octave:3> cos(x)

也就是说，Octave会计算每个元素的正弦值。

3. 命令2中，我们生成了一个向量，命令3的机构生成了行向量。如果我们使用列向量作为cos函数的输入：

        octave:4>cos(x')

   会返回列向量。

**刚刚发生了什么**

命令1里，我们使用pi作为cos函数的输入参数。现在，严格来讲，pi本身也是一个函数。如果我们调用pi函数，不带输入参数或者括号，它简单地返回数$\pi$。

命令3的输出cos（$\pi/2$)和cos（$3\pi/2$)不是如我们所想，精确为0。这主要是因为计算机计算是的有限数值精度所致。但是，从结果看，我们可以看到数值很接近于0。命令3里，我们看到cos函数返回行向量，因为输入参数为行向量。通常如果我们调用cos函数作用于nxm矩阵（或者高维矩阵），它会简单地返回每个值的正弦值。对于大部分Octave函数而言，这都是成立的，值得注意。

命令1和4显示了另外一个重要点，对于函数对于输入参数的操作会在函数调用前被执行。命令1中，调用了pi函数，函数的返回值作为cos函数的输入。命令4里，向量x首先被转置，得到的结果作为cos函数的输入。对于所有Octave函数而言，这都是正确的。

下表列出了Octave内置的基本数学函数。它们与cos一样方式调用：

除了上面表中列出的函数以外，所有三角函数是有导数的。比如，正弦函数的反函数为asin函数。

下面的命令会得到相同的结果：

        octave:5> exp(I * pi)
        octave:6> power(e,I * pi)
        octave:7> e.^(I * pi)

因此，Octave可以使用复数输入参数作为数学函数的输入参数。

**Octave里的多项式**

Octave使用一种特别的方式处理多项式。作为例子，考虑一下x的3次多项式函数f：

$$f(x)=2x^3+10.1x^2+6$$

我们使用含系数的向量来表示该多项式：
$$c=
\begin{bmatrix}
2 & 10.1 & 0 & 6
\end{bmatrix}
$$
向量中第1项为最高次的系数，最后一项是常数项。多项式中没有1次项，所以向量c中该值为0。我们现在可以对函数求值或者使用polyval推出x=0时的值：

        octave:8> c=[2 10.1 0 6];
        octave:9> polyval(c,0)
        ans=6

或者，你也可以使用向量作为输入来计算范围。比如，向量变量x，如命令2中定义：

        octave:10> ployval(c,x)

第2章里，我们学会了Octave里的操作符，因此，你也可以使用：

        octave:11> 2*x.^3+10.1*x^2+6

**更多复杂的数学函数**

Octave还给你提供了除基本数学函数外的很多函数，比如，多种Bessel函数。因为第2章里你已经知道了不同数学操作符，你也可以将这些数学函数揉合在一起：

**实战时刻--整合数学函数**

1. 让我们尝试计算下面函数的值域：
$$f(x)=e^{-5\sqrt x}sin(2\pi x)$$

        octave:12> x=0.5;
        octave:13> f=exp(-5*sqrt(x))* sin(2*pi*x)

2. 使用更为向量化方式：

        octave:14> x=[0:0.1:1];
        octave:15> f=exp(-5*sqrt(x)).* sin(2*pi*x)

**刚刚发生了什么**

命令12和13所做的事情是很明白的。命令15中，我们必须使用逐个元素操作符.\*。如果我们不这样做，Octve就会运行矩阵乘法，应为exp(-5*sqrt(x))和sin（2*pi*x）都为向量。

我们也可以使用命令13中的；也就是说，命令14是更加一般化版本，对于标量，向量和矩阵数组均有效。

方程（3.3）中的函数为标量函数，将实数映射成另一个实数。函数也可以将2个实数映射成一个实数。方程组（1.1）就是该函数的一个例子，让我们试一个简单的，如：

在Octave解释器里构建。

方程（3，3）里的数学函数是标量函数的一个例子。你可以计算向量函数的值域。比如函数：

Octave也许会找到值域，像这样：

我们会转向方程（3.4）和（3.5），当我们学会如何对这些函数作图时。

**辅助函数**

第2章里，我们使用了相当一些辅助函数。例子中有ismatrix,real,eye,ones。辅助函数的工作方式与Octave中的数学函数有所不同。比如，使用非整数调用eye函数是没有意义的，尝试一下，看看会发生什么？

与其累赘地将整个复杂函数解释一遍，不如挑选一些我认为比较重要的辅助函数加以介绍，从这些函数中，解释一些通用的行为。

**产生随机数**

回想一下函数ones和zeros能够帮助我们生成数组，其中所有的元素分别为值1或者0。函数rand做通用的工作，不过生成的元素来自与0和1（不包括）之间的均匀分布。为了初始化一个包含随机分布元素的3x5数组，我们可以使用：

        octave:20> A=rand(3,5)

就像我们使用函数zeros和ones。如果rand函数不带输入参数（完全不写括号也一样，它会返回单个随机数。

你经常需要从不同的分布中生车随机数。除了均匀分布随机数，Octave还可以生成：

1. randn：平均值为0，方差为1的正态分布（你可以用它产生任意平均值和任意方差的正态分布）。
2. randg：gamma分布。
3. rande：指数分布。
4. randp：泊松分布。

randn,randg和rande的调用参数与rand函数一样，也就是，输出数组的维度。对于randp，你还需要指定平均值作为第一个输入参数。如果你有什么疑问，输入help randp。

**min和max函数**

Octave为你提供了一个函数来返回一维数组的最小值。但是，它也可以调用来处理A，比如：

        octave:21> min(A)

也就是，min计算矩阵A中每列的最小值。如果我们将min应用于向量。比如，应用于命令21中生成的结果：

        octave:22> min(ans)

由此，获得了ans中向量的最小值。这个值就是矩阵A的最小值。结合命令21和22，我们可以直接得到A的最小值：

        octave:23> min(min(A))

函数max会获得数组的最大值，就像min函数。

**数组排序**

让我们看一下另一个Octave函数的例子，也就是sort。该函数为你对数组元素排序。sort函数是Octave函数的例子，可以使用不同输入和输出参数，依赖于你想如何让sort函数运行，让它返回什么信息。最简单的调用sort函数是赋予函数单个变量，比如矩阵A作为输入参数。A会按列进行排序：

        octave:24> sort(A)

除了以升序来对A进行排序以外，我们还可以以降序对元素进行排序，使用模式输入参数为“descend”（或者‘descend’）。你也可以按行进行排序，甚至可以要求返回排序后在原索引的数组。让我们看一个这样的例子:

        octave:25> [S i]= sort(A,2,"descending")

sort函数的第二个输入参数告诉sort对矩阵A按行进行排序。如果你希望按列排序，你可以删去第2个参数或者使用值1。

sort总共有12不同的调用方式--其中一些是相同的。通常sort如下调用：

        [s i]= sort(A,dir,opt)

如果我们比较通用的语法格式，我们会看到S和i为输出，A，dir和opt为输入参数。如果sort不带输出参数或者一个输出参数，它将返回列表中的第1个。对于大多数Octave函数来说，这是真的。再一次，你可以使用help函数看一下如何调用函数。

**find，any和all函数**

我们经常使用find函数，并且给你展示一下这个函数是值得的。我们将第2章里学会的各个函数进行整合是非常强大的。find函数返回数组中非零元素的索引。比如：

        octave:26 [i j]=find([0 0;1 0])

也就是说，第2行第1列是非零元素。让我们尝试使用find函数应用更有用，如果A
中的元素小于0.5？

        octave:27> [i,j]=find(A<0.5)

注意，我将输出保存至变量i和j中，阻止输出值屏幕以节省空间。现在，从第2章开始，我们知道如何子啊find函数中会返回含0和1值的矩阵。find只是简单地返回举证中值为1的索引。让我们检查一下我们是否得到我们所希望的，比如

        octave:28> i(1),j(1)

命令20中检查了矩阵变量A，我们看到了第3行第1列小于0.5，正如命令28中发现的。跟上面的sort函数一样，find函数也可以使用不同方式进行调用。输入help
find看看怎样。

函数any和all和find是有关联的。不同指出是any函数返回真值，如果数组中的任一元素为非零值。而all函数返回真值，如果数组中所有元素均为非零值。两个函数均是按列方式工作，如果输入参数为矩阵。让我们解释一下：

        octave:29> any([0 0;1 0])
        octave:30> all([0 0;1 0])

命令29中，输入矩阵由两列构成。第1列拥有非零元素，但是另外一列没有。any函数因此返回1和0.另外，all函数返回2个0值，因为两列中都含有0值元素。

**floor，ceil，round和fix函数**

通过一些例子也许是最方便的方法对这4个函数进行说明。

**实战时刻-尝试floor，ceil，round和fix函数**

1. floor函数：

        octave:31> floor(1,9)

2. ceil函数：

        octave:32> ceil(1.1)

3. round函数：

        octave:33> round(1.9)

4. fix函数：

        octave:34> fix(pi)

**刚刚发生了什么**

命令31中，我们看到floor返回小于输入参数的最大整数，ceil返回了输入参数的最大整数，round函数简单地将输入参数修约值最近的整数，而fix函数返回实数的整数部分。根据这些定义，我们有：

        octave:35> floor(-1.9)

如果输入参数是数组的话，这4个函数是按每个元素进行的。

**sum和prod函数**

sum和prod函数是非常有用的。他们的基本功能就是将数组中的元素相加或相乘。让我们看两个简单的例子：

        octave:36> sum([1 2;3 4])
        octave:37> prod([1 2 3 4])

我们也可以使用cumsum和cumprod函数计算累计加法和乘法：

        octave:38> cumsum([1 2;3 4])
        octave:39> cumprod([1 2 3 4])

**绝对值函数**

Octave拥有一个abs函数来计算绝对值。回想一下，对于复数z=x+iy的绝对值统购|z|=给出。让我们看一些计算绝对值的例子：

        octave:40> abs(2.3)
        octave:41> abs(-2.3)
        octave:42> abs(2+2i)
        octave:43> abs(-2-2i)

abs函数是一按元素进行工作，如果输入参数是一个数组。

**复数输入参数**

除了上面提到的abs函数，我们不会想象复数是如何工作。既然我们已经知道如何计算绝对值，我们可以包含一些例子来看一下复数作为输入参数后是如何工作的。比如，让我们找出复数数组的最大值：

        octave:44> max([1+2i,2+2i,2-0.1i])

你可能想当然max函数会返回实数部分和虚数部分的最大值，但是没有。max返回了具有最大绝对值的元素，当然，min函数会返回绝对值最小的元素。

如果将sort函数应用于复数，它会按照绝对值对元素进行排序。比如

        octave:45> sort([1+2i 2+2i 2-0.1i])

尝试将复数用作其他函数的输入参数。

**操作函数**

 操作函数会对输入参数运行更多的复杂操作。为了这个目的，Octave用户会用到高度优化的算法和已有的库，如LAPAK或者FFTW。当然，辅助函数sort也是基于非常复杂的算法，但是操作本身（如数组排序）是相对简单。

 **线性方程**

 第2章里，我们学会如何求解线性方程使用左除。我们也学习了如何计算矩阵的逆。Octave还可以做更多的线性代数操作，我们在后面会加以讨论。

 **实战时刻--使用Octave求解高级线性代数**

 1. 计算2x2矩阵的行列式是很简单的，但是对于3x3矩阵来书，计算是非常乏味的，更不用说更大的矩阵。Octave拥有函数det为你做这件事：

        octave:46> A=[2 1 -3;4 -2 -2;-1 0.5 -0.5];
        octave:47> det(A)

    回想线性方程的行列式只对方阵nxn是有定义的。Octave会发出警告信息，如果你输入非方阵参数。

2. 让我们稍微改动一下矩阵A：

        octave:48>A=[2 1 -3;4 -2 -2;-2 1 1]
        octave:49> det(A)

结果与第2章里得到的结果一样。A没有满秩，所有，行列式为0.

3. nxn矩阵的特征值可以通过下面的方程得到：
$$det(A-\lambda I)=0$$

   Octave中计算特征值，我们可以使用eig函数：

        octave:50> A=[1 2;3 4]
        octave:51> eig(A)

4. eig可以返回特征向量。但是，给定2个输出，输出序列该别了第1个输出和第2个为特征向量。Octave里，你输入：

        octave:52> [V,L]=eig(A)

特征向量在变量V中的列中给出，特征值在L中的对角元素。

**刚刚发生了什么**

我们已经在命令46-51中讨论过。命令52里，我们包含了特征值向量的计算。注意，输出已经变了，当我们使用2个输出来调用eig函数时，这种行为在Octave函数中并不常见。

现在，回想一下，特征值向量v对应的特征值由线性方程系统给出：
$$(A-\lambda I)v=0$$

我们可以将公式写成Bv=0,其中$B=A-\lambda I$,也就是说特征向量是矩阵B的零空间（核）。Octave里，我们可以直接结算零空间：

        octave:53> lambda=L(1,1);
        octave:54> B=A-lambda*eye(2);
        octave:55> null(B)

恰红特征向量对应的特征值为-0.3722，与命令52输出的结果一致。顺便问一下，矩阵B的阶是多少？既然你可以计算零空间，你也可以计算矩阵的迹。该函数称为orth函数，与null函数工作方式一样。下面的表列出了我们这里和第2章里涉及的线性代数函数：

**多项式**

上面，我们学过Octave中如何用多项式系数来表示多项式。这里，我们再熟悉3个函数来帮组我们计算根，多项式的积分和导数。

命令8中我们初始化数组c为【2 10.1 0 6】来表示方程（3.1）的多项式。为了找出多项式的根，我们使用：

        octave:56> roots(c)

就是说，曲线通过x轴一次。

函数f的不定积分由下面公式给出：
$$\int $$

**二维作图**

本章的后半部分，我们会讨论你如何使用Octave来作图。自从版本3.0.0以来，Octave开发小组做了很多工作来改进作图接口，来最大程度上与matlab兼容。同时，作图程序也得到很大改进，作图设施变得令人印象深刻。

取决于你使用的Octave版本，作图程序也许没有支持所有的作图命令，我们这里涉及的。图形色输出也会有所不同。

**实战时刻-开始作图**

让我们尝试对方程（3.1）给出的多项式f在区间x[-5.5;1]:

        octave:59> x=[-5.5:0.1:1];f=polyval(c,x);
        octave:60> plot(x,f)

你会看到一张像下面一样的图形：

**刚刚发生了什么**

plot函数的第1个输入参数是x变量，用来作为x数轴的值。第2个输入参数f被用来指定y轴的数值。注意，这两个变量必须有相同的长度。如果不是的话，Octave会生成一个错误。你也可以使用plot调用单个输入参数。在该例子中，输入变量会对索引作图。

我们绘出了函数f的图形，我们实际上是将各个离散的数据连接起来，使用直线。因此，为了平滑化，你需要足够的点来作图来对图形表现良好。

**作图和设置**

上面的绘图中有一些看起来不够令人满意的地方：

1. 数轴不准确，比如说，x轴从-6开始，而不是-5.5 。
2. 绘图和窗口盒子线条太细了。
3. 数轴没有做标签。
4. 数轴上的数字太小了。

实际上，我们可以修复这些问题，我们有多种方式进行，我们这里使用最为灵活的方式。

为了做到这些，我们需要：

1. 了解更多plot函数；
2. 学习更多set函数功能。

plot函数的通用语法是：

        plot(x,y,fmt,property,value,...)

我们已经讨论过前2个输入参数,输入参数fmt为绘图格式或者方式。如果你删除了这个参数，Octave会使用默认的蓝线。第4个输入参数property是图形的性质（比如，颜色或者线宽），输入参数alue为性质的值。后面的省略号说明你可以指定许多性质和值。

通常，set函数如下调用：

        set(handle,property,value,...)

其中handle为绘图对象句柄（比如，数轴的句柄），property是图形对象的性质（比如，数轴的范围），value指其值（比如，区间为-5.5到1）。

**实战时刻--改变图形的性质**

1. 让我们尝试改变上面的图形，首先：

        octave:61> plot(x,f,"linewidth",5);

   这个命令同样会生成上面的图形，但是我么指定了图形的性质linwidth为5而不是1.
2. 为设定数轴的正确限度，我们使用：

        octave:62> set(gca,"xlim", [-5.5 1])

3. 我们也可以使用use来设定窗口盒子的线宽和数轴上字体的大小：

        octave:63> set(gca,"linewidth",2)
        octave:64> set(gca,"fontsize",25)

4. 也可以使用set设定数轴的标签。这里，性质为“xlabel”和”ylabel”，使用text函数来指定性质的值：

        octave:65> set(gca,"xlabel", text("string","x",       "fontsize",25))
        octave:66> set(gca,"ylabel",text("string","f(x)","fontsize",25))

5. 生成的图片应该该下面的很接近：

**刚刚发生了什么**

命令62里，句柄输入参数gca实际上是一个函数，为“get current axis”的缩写。性质“xlim”表示x数轴限制，我们设定为-5.5至1.

你也可以设定和改变手肘标签使用xlabel和ylabel函数，你可以指定数轴的范围使用axis函数。但是，set函数更加灵活，一旦你习惯了，你会发现工作起来还是很容易的。

正如你从接口中看到的，set函数可以调用一些的性质及其值。因此，命令62-66可以合成一个set函数调用：

        octave:67> set(gca,"xlim",[-5.5 1],"linewidth",2,"function",25,"xlabel",text("string","x","fontsize",25),"ylabel",text("string","f(x)","fontsize",25))

**在你的图上加入线条和文本**

你也可以将线条和文字加入值你的图形上，加以突出。比如，你也许想指向多项式的根。为了加入线条，我们使用line函数：

        octave:68> line([-5.16 -4],[-2 -20],"linewidth",2)

这里，直线从（x,y)=(-5.16,-2)到(x,y)=(-4,-20),宽度为2.加入文字来说明直线值的是什么是带有信息性的。为了这个，我们可以使用我们上面看到的text函数：

        octave:69> text(-3.9,-23,"root","fontsize",20)

两个数字（x，y）给出了文字“root”的位置。让我们加入更多信息：

        octave:70> line([0 0],[5 -20],"linewidth",2)
        octave:71> text(-1.0,-22,"local minimum","fontsize",20)

下面显示的图中显示了加入线条和文字之后的样子：

**图形样式和颜色**

回想一下函数语法中你可以指定的plot函数的格式。比如，将方程（3.1）画成圆形，而不是直线，你可以使用：

        octave:72> plot(x,f,"o")

现有的绘图被删除，就像数轴范围和数轴标签可以改变或者消失一样。你可以发现点会太大或者太小。性质“marksize”可以帮助你来重新设定点的大小：

        octave:73> plot(x,f,"o","marksize",4);

你可以试验一下标注大小。其他点的格式有*,+,X,.,和^,这些都可以和-一起联合使用来将点连接成一条线。

你也可以使用指定Octave中你想要的颜色通过性质color。让我们重新绘制多项式的图，使用红色来连接直线。

        octave:74> plot(x,f,"o-","marksize",4,"linewidth",2,"color","red")

注意，因为我们重新绘制图形，我们需要指点数轴的性质，正如命令75所做的。下面的图显示了在该风格和颜色下是什么样子。

**标题和注释**

绘图也可以配上标题和注释。后者更加有用，当你将几个图形绘制至同一个图中。加入注释表明你使用的f函数的值域：

        octave:76> legend("f(x)")

你也可以使用set函数加入标题：

        octave:77> set(gca,"title",text("string","My favorate loynomial","fontsize",30))

注意，title是一个数轴对象句柄的有效性质，但是注释不是。

**网格**

有时候，网格有助于引导你的眼睛。为了开启网格，使用：

        octave:79> grid on

取消网格，简单地输入：

        octave:80> grid off


**fplot函数**

许多Octave用户使用fplot函数。该函数可以用于绘制数学函数的图形，因此使用前缀f。这一点与plot不同，绘制两个数组。绘制正弦函数，从0到$2\pi$,使用50个数，你可以输入：

        octave:81> fplot("sin",[0 2*pi],50)

**清除图形窗口**

就像我们可以将变量从工作区中删除，你也可以删除图形。命令：

        octave:82> clf

可以这样做。注意，图形窗口仍然存在，但是内容被删除了。

**向前走**

除了绘图以外，Octave还可以做更多的事情。本节中，镍会学校如何在当图片中绘制多个图形，如何绘制多个窗口，如何使用子图。

为了展示如何在单个窗口中绘制多个图形，我们绘制两个多项式：

$$f_1(x)=2x^3+10.1x^2+6 and f_2(x)=2x^3+10.1x^2-10.1x+6$$

于单个窗口。注意，$f_1$与方程（3.1）中给出的多项式一样。

**实战时刻-同一个窗口绘制多个图形**

1. 我们开始定义域，和系数来表示多项式：

        octave:83> x=[-5.5:0.1:2];c_1=[2 10.1 0 6];c2=[2 10.1 -10.1 6];

2. 我们然后计算$f_1$和$f_2$的值域：

        octave:84> f_1=polyval(c_1,x);f_2=polyval(c_2,x);

3. 然后绘图：

        octave:85> plot(x,f_1,"linewidth",5,x,f_2,"linewidth",5,"color","red")

  设定好数轴范围，字符大小等等。图形窗口看起来就像下面这张。

  **刚刚发生了什么**

  命令85里，我们看到plot函数可以在单个调用里绘制多个图形，你甚至可以指定每张图形的性质及其值。

  还有，你可以使用命令hold on来强制Octave来不要删除图形；命令85以外，你可以使用：

        octave:86> plot(x,f_1,"linewidth",5);
        octave:87> hold on
        octave:88> plot(x,f_2,"linewidth",5,"color","red");

当你需要Octave停止“维持”，你简单地输入：

        octave:89> hold off

你也许很奇怪下标是如何做到的。很容易!使用下划线来表明下一个字符是下标。比如，下面的图形，你使用：

        octave:90> text(-3.9,-23,"f_1(x)")

如果你需要跟多的字符作为下标，你可以使用大括号将字符包起来，比如，“f_{123}(x)"。对于上标，你可以使用^{帽子},而不是使用下划线。这个特点，也许还没有被你的绘制工具支持。

**多个图形窗口**

Octave里，你可以一次绘制多个窗口。为了绘制图形窗口2，比如，你输入：

        octave:91> figure(2)

下次你使用plot函数，图形会出现在窗口2.你可以退回值，绘制至窗口1：

        octave:92> figure(1)

如果你打开了多个窗口，忘记了哪个是当前在用的，你可以使用gcf函数：

        octave:93> gcf

答案告诉我们当前图形为窗口1.

**子图绘制**

除了打开多个图形窗口以外，你还可以将几个图形绘制至一个窗口上。如果你需要绘制子图，你需要用二维n行m列的数组提示Octave将窗口分割成多个窗口。比如，将图形窗口初始化成2x3,也就是6个图形，你使用命令：

        octave:94> subplot(2,3,1)

subplot函数的前两个输入参数设定了窗口维度，第3个参数告诉Octave使用索引1来绘制子图窗口。索引以按行执行，正像下面图形中所示的。图中显示了一个窗口.

现在你可以在这个子图中使用前面学过的plot，set,line和text命令。转换至子图2，你简单地输入：

        octave:95> subplot(2,3,2)

子图的功能非常有用，特别是你想进行。比如，你想缩放图形的一个特殊部分。让我们说，你想绘制方程（3，10)中函数f1和f2的图形。除了绘制在一个窗口以外，我们还可以将f2作为内图。

**实战时刻-绘制内图**

1. 首先输入命令：

        octave:96> subplot(1,1,1)

   会打开一个主窗口，允许你绘制子图。

2. 现在，绘制函数f1的图形，线宽为5，我们使用：

        octave:97> plot(x,f_1, "linewidth",5)

3. 设定数轴范围保证内图的空间：

        octave:98> set(gca,"xlim",[-6 2.5],"ylim",[-50 70])

4. 你想插入更小的子图窗口，我们指定了内图的左下角的位置，长度和高度，我们。比如：

        octave:99> axes("position",[0.3 0.2 0.3 0.3])

5. 为了绘制内图，我们简单地使用基本的plot函数：

        octave:100> plot(x,f_2,"red","linewidth",5)

**刚刚发生了什么**

命令99里，axes函数用来控制数轴的性质。第1个输入参数是数轴性质“position”，第2个输入参数为对应的值。不幸的是，你不能通过set来控制这个值。现在，参数值指定了内图窗口位于主窗口的左下角，

现在你可以使用set函数将数轴和文字性质改换至你想要的值。下面的图像显示了最终的我们努力的成果：

我们可以使用axes函数加入更多的子图，你不能回到主窗口或者其他内图，来做更改。在绘图变成你想要的之前，你需要做一些尝试。

我们对plot函数和set函数不同的性质及其值的总结来结束本节：

<table>
    <tr>
        <td>Foo</td>
    </tr>
</table>   

**保存图形**

你可以将你的绘图保存至一个文件使用print函数，比如：

        octave:101> print("polynom.png","-dpng");

会打印当前窗口至文件“polynom.png”用png（Portable Network Graphics）格式。注意，格式前面加-d。只是“device”的缩写。

print函数支持大多数通用的格式：

输入help print可以看到支持的扩展选项。


**三维作图**

方程（3.4）和（3.5）定义2个数学函数，跟前面提到的简单多项式比较，不易于可视化和绘图，方程（3.4）为标量函数，标量有2个。该函数的的图可以通过surface plot可视化。方程（3.5）为向量，可以在3维空间化参数曲线。本节里，我们会看到如何做。

**Surface plot**

让我们开始对方程（3.4）作图，在区间。既然我们使用离散的点，我们需要对不同组合的点的f求值域。Octave中做这个是比较简单的，我们生成了2个mesh grid可以包含所有我们的组合，当我们计算函数f的图形时。

**实战时刻-制作surface plot**

1.  首先我们定义定义域：

        octave:102> x=[-2:0.1:2];y=x;

2. 然后我们生成mesh grid：

        octave:103> [X Y]=meshgrid(x,y);

3. 现在我们可以计算函数f的值域，采用方程（3.4）对于所有的x和y组合：

        octave:104> Z=X.^2-Y.^2;

4. 制作surface plot我们是使用：

        octave:105> surface(X,Y,Z)

   结果如下：

**刚刚发生了什么**

命令103中，X只是一个简单的矩阵，列复制自x，Y是复制子y中的元素。从X 和Y ，我们求出函数值，正如命令104中所做的。我们可以看到Z为矩阵。同时，注意surface函数使用了mesh grid，得到Z矩阵作为输入。

你当然也可以更换性质，就像我们对二维作图一样。比如：

        octave:106> surface(X,Y,Z,"linewidth",4)
        octave:107> set(gca,"linewidth", 2, "fontsize",20,"xlim",[-2 2])
        octave:108> set(gca,"xlabel",text("string","x","fontsize"),30)
        octave:109> set(gca,"ylabel",text("stirng","x","fontsize",30))

你也可以加入文字字符和直线至你的3维图中：

        octave:110> text(-3.2,1,3,"f(x,y)","fontsize",30)
         octave:111> line([0 0],[0 1],[0 2],"linewidth",5,"color","red")
        octave:112> text(-0.5,1.5,1.8,"Saddle point","fontsize",25)

注意，你必须指点3个坐标点，因为我们在3维空间里。结果政务上面的图片。

**视图和colormap**

你可以改变视图位置来查看绘图。这个功能由iew函数实现。view函数的输入参数为。看下面的示意图：

将视角设定为$(\sigma,\theta)=(35,30)$,使用：

        octave:113> view(35,30)

结果就会显示上面的surface plot。

你可以更换surface的颜色，使用colormap函数。命令114和115展示了一些这种例子，使用通通的视角：

        octave:114> colormap("gray");view(-35,30);
        octave:115> colormap("summer");view(0,0);

结果如下所示：

有效的颜色有：

你也可以使用mesh函数。就像surface函数一样，除了步步将网格涂上颜色。尝试一下吧！

**Contour plots**

相对surface plot作详细的观察是困难的。界面绘图可以有帮助。Octave里，你可以使用三函数的其中一个来实现：contour,contourf和contour3.它们像surface一样被调用，不如，contourf(X,Y,Z),contour3(X,Y,Z).你也可以指定函数你想要的层次（第4个输入参数）。默认值为10.你也可以控制性质。让我们看2个例子：

        octave:116> contourf(X,Y,Z,20);
        octave:117> contour3(X,Y,Z,"linewidth",6);

命令116和117的结果显示如下：

**三维参数作图**

最后，让我们绘制方程（3，5）中给出的函数的图形。正如上面提到的，这是一个空间上的参数化曲线：

**实战时刻--绘制参数曲线**

1. 首先，我们需要初始化变量x，比如：

        octave:118> x=linspace(0,10*pi)';

2. 然后，我们计算函数f的值：

        octave:119> f=[cos(x),sin(x),exp(-0.5x)];

3. 检查我们的大小是否正确：

        octave:120> size(f)

4. 现在我们可以使用plot3函数绘图：

        octave:121> plot3(f(:,1),f(:,2),f(:,3),"linewidth",4)

5. 设定正确的设置，我们可以使用：

        octave:122> set(gca,"linewidth",2,"fontsize",30)
        octave:123> set(gca,"xlabel",text("string","x","fontsize",30))
        octave:124> set(gca,"ylabel",text("string","y","fontsize",30))
        octave:125> set(gca,"zlabel",text("string","z","fontsize",30))
        octave:126> set(gca,"zlim",[0 1.2])
        octave:127> text(0.9,-0.25,0.9,"t=0","fontsize",30)
        octave:128 view(20,30)

  最后得到的图如下所示：

  **刚刚发生了什么**

  命令119里，我们计算区间里的值，注意命令118里的转置操作！命令120里，我们检查了变量f的大小，命令121，我们使用plot3函数绘制曲线，我们改变一些图像的设置，让它变得更好一些。
