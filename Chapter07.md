
对于许多不同的分析方法，Octave都是理想的工具。用到的数据可以通过其他程序产生，或者从数据库中收集，然后导入至Octave工作。基于一个由不同函数组成的庞大“武器库”，构成了Octave中的数据分析工具。本章里，我们只讨论其中的一小部分，即如何进行最简单的统计分析，函数拟合和基于快速傅立叶转换（FFT）的傅立叶分析（或者谱分析）。

简单地说，阅读完本章，读者可以学会：

 - ASCII文件导入Octave工作区的进一步。
 - 如何使用Octave进行简单的统计描述。
 - 不同函数来拟合数据。
 - 如何使用Octave进行傅立叶分析。

**数据文件导入**

对一个特别的问题进行统计分析时，读者经常需要将一些数据储存至文件中。本书第4章里，已经告诉读者如何将自己的变量（或者整个工作区）保存为各种文件格式，并将它们重新导入。Octave还可以导入由其他程序产生的文件。读者在进行这些操作的时候会遇到一些不方便的地方，我们在这里加以讨论。接下来，我们只考虑ASCII文件，一种可读的文本文件。

读者使用load命令将数据从ASCII文件中导入数据时（参见第4章），数据会被视为一个二维数组，我们可以将数据看作一个矩阵，其中行即为矩阵的行，列即为矩阵的列。对于一个定义良好的矩阵，数据所有的行中含有相同的列数（同时，所有的列中有相同的行数）。比如，文件series.dat中的内容为：

        1      232.1    334
        2      245.2    334
        3      456.23  342
        4      555.6    321

本书第4章里，我们已经学会如何将该数据导入至Octave的工作区里：

        octave:1> load -ascii series.dat

这里，数据会被储存于名为series的变量里。实际上，即使读者不指明ASCII文件格式，Octave可以导入数据。行数和列数会是：

        octave:2>  size（series）
        ans =
          4   3

我倾向于使用 .dat扩展名，但是再次强调，这是可选项，可以使用任何读者自己喜欢的扩展名，如.txt,.ascii,.data,或者根本就不写。

数据文件里，读者可以加入：

 - Octave 注释
 - 用于分割数据块的空白行（blank lines）（或者说空行empty rows）
 - 用于数据分割的Tab字符，单个或者多个空格

因此，下面的数据文件可以成功地导入Octave：

        # 第1个数据块
        1      232    334
        2      245    334
        3      456    342
        4      555    321

        #第2个数据块
        1      232    334
        2      244    334
        3      456    342
        4      555    321

得到的变量是一个8行3列的矩阵。如果你知道数据块的数目和数据块的大小，读者就可以分割数据块。

现在，下面的数据储存于文件bad.dat，将不会导入至Octave的工作区：

        1      232.1    334
        2      245.2
        3      456.23
        4      555.6

因为第1行有3列，而2-4行只有2列。如果读者试着将该文件导入Octave，Octave会出现下面的错误提示：

        octave:3>load -ascii bad.dat

**简单统计描述**

本书第5章中，我们实现了Octave函数micintgr，以及它的向量化版本mcintgrv。该函数求取数学函数f（值域必须为正）在区间[a，b]上的积分值。Octave函数基于Monte-Carlo方法，因此，返回值积分是一个随机变量。我们计算时，至少需要将结果表示成平均值或者其他合适表示方式的中间值，以及其统计不确定度。对于其他随机变量来说也一样，比如班级里学生的身高，植物叶子的长度等等。

在本节里，我们会使用Octave来对随机变量进行简单统计描述。

**直方图和统计矩**

让我们使用向量化版本的Monte Carlo积分器对方程（5.9）计算1000次积分：

        octave:4 > for  i=1:1000
        > s(i)=mcintgrv("sin",0,pi,1000)
        >endfor

数组s现在包含了一系列我们知道值约为2的数字。在我们做任何数量统计描述之前，较好的做法是先画出数据的直方图，最简单的实现方法是使用Octave里的hist函数：

        octave: 5> hist(s,30,1)

hist函数的第一个参数s是随机变量，第2个变量是间隔数（number of bins,这里我们采用30)，第三个变量是直方图中高度的总和（这里设定值为1)。直方图如下图所示。如果使用命令hist（s）来调用hist，s会被分成10组，高度的总和为sum（s）

从图中，我们可以看到mcintgrv产生了一系列的随机数字，看起来符合均值为2的正态分布（或者说高斯分布）.这正是我们所需要的。可以通过样品均值的定义来很好地描述变量：
$$\bar s=\frac{1}{N}\sum_{i=1}^n s_i, (7,1) $$

公式中N为样本数（这里为1000），si为第i个数，样本方差可以表示成：
$$var(s)=\frac{1}{N-1}\sum_{i=1}^N(s_i-s)^2,(7,2) $$

方差是分布宽度的测量度，因此可以用来估计均值的统计不确定度。有时候，可以使用标准差，而不是方差。标准差是方差的平方根$=\sqrt {var(s)}$


在Octave里计算样本的均值，样本方差和标准差，读者可以使用：

        octave:6 >mean(s)
        ans=
              1.999
        octave:7>var(s)
        ans=
              0.002028
        octave:8>std(s)
        ans=  
              0.044976

数据的统计描述里，我们也可以包含偏度（skewness）来描述均值分布的对称性。如果偏度为正，表示分布对于均值来说是拖尾的。如果偏度为负，表示。偏度定义如下：

$$skew(s)=\frac {1}{N} \sum_ {i=1}^N{(\frac{s_i-\bar s}{\sigma})^3} $$

在Octave里我们如下计算：

        octave:9> skewness(s)
        ans=
              -0.15495

结果有一点奇怪，因为我们假设直方图中的来自于一个正态分布，以均值为中心的对称分布，因此偏度为0.该示例说明了重要的一点，使用偏度来度量分布对称性需谨慎。需要非常大的数据才会有一个良好的估计值。

读者也可以计算峰度（kurtosis）来评价样本分布相对于正态分布的平坦性。负的峰度表示更平坦分布于均值，峰度为正表示更尖锐分布于均值。峰度用下式定义：

$$kurt(s)=\frac{1}{N}$$

可以使用kurtosis函数来计算：

        octave：10> kurtosis(s)
        ans=
              -0.02310

**样本统计矩**

正如读者所知道的，样本均值，方差，偏度和峰度是样本的样本统计矩。均值为一阶统计矩，方差为二阶统计矩，等等。现在所示，统计矩不是唯一的。你可以，比如说，定义k'绝对样本统计矩p和k'样本中心统计矩如下：

$$p_a^k=\frac{1}{N}\sum_{i=1}^N s_i^k and p_c^k=\frac{1}{N}\sum_{i=1}^N(s_i-\bar s)  (7.5)$$

注意，第一个绝对统计矩为仅仅为样本均值，但是第一个中心矩为0.在Octave里，读者可以很轻而易举地使用moment函数来得到样本统计矩。比如，读者可以计算二阶中心统计矩：

        octave：11>moment（s,2,'c')
        ans=0.002022

这里，第一个输入参数为样本数据，第二个参数定义了统计矩的阶数（order），第三个参数指明我们希望得到中心统计矩'c'或者绝对统计矩'a'(函数的默认选项）。与命令7比较，输出有所不同-为什么不同呢？

**比较数据集**

上面,展示了如何读者使用Octave对单一数据集进行简单的数据描述.本节中,我们可以看到如何统计比较两组数据集.统计比较的准确意思是什么呢?比如说,我们可以检验两组数据是否具有同样的均值(该检验被称为t检验),或者它们具有同样的概率分布(卡方检验).

Octave里,读者可以进行几乎所有的统计检验: student's t检验,z检验,Kolmogrov-smirnove检验,等等更多的检验.这里我会给读者展示如何机型单因素t检验和如何计算Pearson相关系数.

**相关系数**

 下面表单中显示了2~15岁男孩的升高和体重:

可以看到,身高和体重均与年龄相关.为了表明两个数据集是否真的相关,我么需要更加谨慎.通常,两个数据集之间的相关性使用Pearson's相关系数来计算,如下:



公式中是数据集的的变准差,数据集的标准差.rp值接近1表示两个数据集之间的良好相关性.Pearson相关系数很容易通过Octave中的cor(或者corrcoef）。该函数的语法如下：

        r=cor（x，y）

我猜想，上述公式无需解释。

假设我们将所有数据储存于ASCII文件boys.dat中：

        #   Age         weight                Height
        2                12.5                     85.5
        3                13.2                     93.2
        .   .   .

        octave:12> load   -ascii  boys.dat；

我们然后可以找出第2列和第3列之间的相关系数：

        octave：13> cor(boys(：，2），boys（：，2））
        ans=0.9766

两个数据集确实相关，正如我们所期待的。

**Student t  检验**

下面一组数字表示一个班级里21名学生的身高（cm）：

        156.92  140.00  163.20  167.24  149.84  149.21
        166.86  152.01  147.53  157.56  154.48  170.33
        155.82  162.24  161.43  174.94  146.30  151.08
        150.82  154.82  154.49  165.98

均值为157.07cm。国家的均值为161.11cm。在学生身高为围绕均值的正态分布的假设下，我们是否可以说该班学生身高与国家均值是统计上是一致的。Octave中的t_test可以给你提供帮助。一个简单版本的语法是：

        pvalue=t_test(x,m)

函数里pvalue是无效假设（两个均值相等）的概率，x为数据，m是我么检测的均值。

假设我们将身高保存于一个数组heights里，要进行检验，我们使用：

        octave：14 > t_test(heights,161.11)
        ans=0.0508369

结果表明我们不能肯定地下结论说样本班级的平均身高与国家的平均值是一样的。通常，我们pvalue>0.05时接受无效假设，这里我们处于临界的情况。

下面表格里列出了大部分通用的统计检验函数：

**函数拟合**

许多科学领域里，读者希望用函数来拟合数据。函数可以是经验性的也可以是理论性的。很多理由需要这样做，比如如何理论模型与观察值相符，理论可能是正确的，读者可以获取新的自己研究的现象产生新的理解。

本节中，我么会讨论Octave中的拟合功能。我不会对函数拟合的算法进行深入挖掘，这将只用很少的篇幅和较少的内容。

**多项式拟合**

假设我们想调查两个不同高度的家族树木中的叶子长度。下面的视图展示了叶长数据为两个不同的高度的函数，树种A。由于某种原因，我们认为A种树的叶子长度，我们用yA表示，为高度x的线性函数，但是树种B叶子长度yB为树高的3次多项式。因此，我们会检验下面的模型：


可以很好地拟合数据，如果我们使用多项式相关系数作为拟合参数。


Octave中可以直接使用polyfit函数。该函数可以用下面的语法调用：

        [cfit s]=polyfit(x,y,n)

函数里x是独立或者自由变量（本例中为树高），y是测定的数据（叶子长度），n是多项式的幂。输出的第一个参数多项式相关系数的数组，因此长度为n+1，第2个参数为有关拟合的结构信息。我们将会将会在下面结构元素的重要信息。

**实战时刻-使用polyfit**

1. 假设我们已经将数据导入至Octave中，将树A和树N的叶子长度分别命名为yA和yB。相应的高度数据储存于xA和xB.

2. 拟合线性模型于数据yA，我们做如下动作：

        octave:15> [cA sA]=polyfit(xA,yA,1);

3. 我们必须检查拟合是否合理。首先，我么画出拟合直线：

        octave：16>plot(xA,yA,'rs',xA,sA.yf,'r')

红色方块和红线。

4. yB数据的三次多项式拟合采用同样的步骤：

        octave: 17> [cB  sB]=polyfit(xB,yB,3);
        octave: 18> hold on; plot(xB,yB,'bv',xB,sB.yf,'b');

图形如下所示：


**刚才发生了什么？**

polyfit找出了多项式系数cn，，使得多项式（我们的统计模型)y=y(x)和实测数据之间的差值采用某种方法最小化。衡量方式是残差之和，，即：

    找到，使得               最小化。

公式中，N代表拟合点数。

如上述所示，polyfit会返回一个结构体，用于保存拟合的信息。命令16中，我们使用了结构体中的yf，包含拟合值来绘制导致的拟合。我们可以是返回的cA中的相关系数。

        octave: 19> cA

**拟合**

从上面的图中，看起来拟合良好，多项式看起始叶子长度的良好模型。可视化验证拟合和模型通常是不够的。科学家经常选择客观的量化指标进行评估拟合是否令人满意或者不满意。

polyfit储存了结构体中的normr，实际上是2-正太的残差，计算公式如下：


这没有任何斑竹，取决于残差的绝对值。你也可以使用相关系数：


读者可以看到，较小的残差，相关系数接近于1；如果拟合不好，改值接近0.不幸的是，polyfit没有给你计算，但是读者可以很容易自己做到。

实战时刻- 计算相关系数

让我们试着计算树种A叶子长度的相关系数。我们只需要根据公式（7.9）：

      octaveL21> denom=(length(yA)-1)*var(yA);

      octave:22> rcor=1-sA.normr^2/denom;

        rcor=0.96801

计算结果表明拟合良好，跟预期一致。

**刚才发生了什么？**

命令21中，我么计算了公式（7.9）中的分母。注意我们并没有计算方差，只是用var来计算方差。从公式（7.9）中，我饿每年可以 看到进入了分母。这个已经用polyfit来计算过，并且保存于normr的结构体中，因此我们可以用它来求得相关系数。

**残差作图**

如果存在系统性拟合和数据偏离，模型将不得不予以放弃。这些偏移也许足够的小，因此不会为相关系数所关注。但是，可以通过残差作图来观察。Octave中，可以直接了当地进行，我将它留作练习由读者来做。

**非多项式拟合**

当然，并不是所有的的数据可以通过多项式模型进行拟合。生长相关现象可以通过指数函数或者幂公式进行拟合。这两个例子用上面的多项式拟合方法加以解决是微不足道的。但是读者也许有特别的拟合模型，需要一个通用的拟合步骤。Octave在这方面也可以加以帮助。

**数据转换**

在我们讨论如何用一个更加通用的函数进行拟合数据之前，值得注意的是，我们可以将拟合函数转换成不同的形式，允许我们使用上面的多项式拟合方法。

数据转换的一个非常简单的例子是用对数函数在公式两边：

通过这种方法，新的变量y'=ln（y),是x‘=ln(x)的线性函数，即，我们可以写成y'=ax'+b',其中q'==ln(b). 我们可以将转换后的数据用polyfit函数来拟合方程（7，11）。记住，将拟合参数b转换回来，b=eb‘。

上面例子中，数据转换是很简单的。读者可能会想到其他可能的转换方式来转换自己的模型。比如说，对数据进行傅立叶转换，模型可能在傅立叶空间中是一个更好的选择。我们会在本章里讨论傅立叶转换。

一般最小平方拟合

如果读者不能对数据进行正确的拟合允许你使用polyfit，读者可以使用leasqr。该函数由优化软件包optim中附带，可以从Octave-forge网页上进行下载。查阅第一章如何安装和载入软件包。leasqr是真正强大的函数，允许读者进行更多复杂的拟合。如果我必须我最喜欢的Octave函数，我想一定是它。

该函数的语法如下所示：

    [yfit pfit  cvg iter  ...]=leasqr(x, y ,p,fun,opt)

描述所有的输入和输出参数需要很多功夫，因此我们在这里仅仅讨论了几个特点，但是这些就足够让我们进入足够深入。如果读者想了解更多，只需要简单的输入：help leasqr

输入参数为：

x:   独立变量
y:  测量值/观察值
p:  初始值
fun： 模型（拟合函数）
opt： 6个可选参数表示每个数据点的权重，最大迭代次数，等等。
leastqr可以返回10个输出函数，前面4个为：

yfit：拟合函数值
pfit：拟合参数值
cvg： 1 表示拟合收敛（可能是成功的），0表示不收敛
iter: 迭代次数

关键问题在于，使用leastqr时，读者必须提供拟合模型，使用Octave函数可以拟合数据。这个函数依赖于至少一个函数，遵循下面的语法。
y=fun（xp）

同样的，x是独立变量，品为参数列表。

我们通过下面2个参数模型来拟合来熟悉leasqr：

来拟合我们自己产生的一些数据。其中，为拟合参数。

**实战时刻-leasqr运用**

1. 让我们产生随机正态分布噪音

        octave:23>x=linspace(0,5);y=1./(1+1.2*.

2.  然后我们使用下面函数定义来指定模型：

        >y=1./(1+p(1)* x.^p(2));
        >endfunction

3.  赋予参数初始值：

        octave:25>p=[0.5 0.01];

4.  我们现在可以用函数来拟合数据：

        octave：26>[yfit pfit cvg iter]=leasqr(x,y,p,"ffun");

    很容易吧！

5.  我们来检查一下拟合算法是否收敛以及迭代次数：

        octave：27>cvg, iter

6.  当然了，拟合参数的值也很重要：

        octave：28>pfit
        p=
            1.1962
            1.7955

结果与我们在供试24中输入的值非常接近。拟合曲线和数据一起作图于下面的图中。

**发生了什么事**

**傅立叶转换**

傅立叶分析的基本原理是傅立叶变换。如果函数f是时间依赖性的，并且是可积分的，f的傅立叶变换可以定义为：

注意函数F为角频率的函数，通常为复数值的函数。通常，f也是复数值函数，但是我们在这里就不对这种情形加以考虑。

现在，假设我们有一个N个离散数据的集合，取样于固定间隔，于。在这种情况下，傅立叶的积分形式可以近似于离散傅立叶变换：

我将会在后面解释索引n的意义，根据采样定理（或者Nyquist-Shannon定理），我们不能随机地选择频率来进行正确的傅里叶分析。但是他们可以
使用下面的公式给出：

这意味着会得到一个很大的频率模式，我们必须有足够的频率采样才有意义，将方程（7.15）代入方程（7.14），假设，假设，我们
得到：

实际上，我们可以直接编码方程（7.16），Octave甚至支持复数，因此，这只用16行代码就可以搞定。但是，这会导致一个级数为N2算法，意味
着操作数目与我们需要与N2成比例。因此，执行时间对于采样规模，运行时间会急剧增加。对于大规模数据集，这不是一个明智之举。纯粹出于好奇，
我们会在后面练习中尝试一下。

**实战时刻-fft函数应用**

1.  让我们对下面的函数尝试一下傅里叶变换：

    其中，使用那个了150个数据，这个函数应用了2个不同的频率（或者模式），将会显示傅里叶变换是两个不同的峰。

2.  生成我们需要使用的数据

        octave：29>N=150；t=linspace(0,2*pi,N);
        octave: 30>f=sin(2*t)+2*sin(3*t);

3.  然后我们简单地转换这些数据：

        octave：31>F=fft(f);

4.  复数向量F本身没有很多信息，因此我们显示器绝对值（或大小）：

        octave：32>plot(abs(F),"O-");

    会产生下面的图：

**发生了什么事**

在命令29，30中，我们生成了数据集，我强烈建议读者尝试一下用f对t作图。我们调用fft函数，画出转换后数据的
绝对值。

事情看起来有些奇怪，我们预期会看到2个不同模式方程（7.17）的。
但是上面的图上显示了4个峰，看起来像图的镜像。这很有意义。从方程（7.15）中我们会看到频率从，

这解释了一个镜像，因为，注意t最大的率
fft输出成2半，前半部分对应于频率0至，后半部分频率从-$\pi$/:

        octave: 35>F=fftshift(F)

在我们对F作图之前，我们应该再次生成我们作图时需要的频率。首先，抽样间隔：

        octave：34>dt=t(2)

然后我们定义方程（7.15）中的n：

        octave：35>n=[-N/2:1:N/2]

但是等一下，数组的长度为N+1,为了纠正这个问题，我们简单地取出了最后一个点（即最高频率的最大值）：

        octave: 36>n(N+1)=[];

根据方程7.15，频率可以如下计算：

        octave：37>freq=2*pi*n./(N * 25);

现在我准备对F作图，这种操作有时被称为magnitude spectrum：

        octave：38>plot(freq,abs(o),'o-')

命令38中得到的图如左边所示，在右边的图中，只有正的频率显示。现在我们看到2个频率出现，可以看到高频部分振动更大。

在上述例子中，我们将含有150个点的数据集进行变换。如果读者改变这个数目。可以看到F的magnitude也会发生变化。点数越多，magnitude越小。产生这种状况的原因是因为fft函数排除了的乘法，见方程（7.16）。因此得到一个谱是独立于点数。我们仅仅将fft和相乘。

改变数据点也意味着改变Nyquist频率。

根据方程7.18，当你进行快速傅里叶变换的时候。频率并不是一个独立变量，而是取决于样本大小和样本间隔。同时，Nyquist频率取值是较大，使得傅里叶变换所有的频率。试剂上$\omega_n$如果不够大（比如说，取样间隔太大）。高频端就会不正确地显示图谱。这就是所谓aliasing。要确保不出现alias问题。

**货币交换率傅里叶分析**

让我们回到货币投资问题，我们需要知道如何执行一个数据的傅里叶分析。因此，我们如何深入，好的。我们还没有准备好。如果我们只是简单地对数据进行变换。在低频区会有一个大峰。这个峰来自于平均汇率不会为0.价格上升趋势。如果我们想要做短期投资。我们主要想知道在高频区的行为。我们因此将这些趋势去除。

**实战时刻-汇率分析**

1. 假设我们将汇率数据倒入变量curr，我们总共有230个数据点，月平均指数如下表示：

        octave：39> m_index=[0：229]；

2. 上升趋势通过终点数据得出：

        octave：40> a=

3. 以数据中减去趋势

        octave：41> curr=curr-a*m_index-b

4. 确认平均值为0，我们使用

        octave: 42>

5. 然后我们对无趋势数据进行傅里叶分析，频率$f=\omega/2\pi$:

        octave: 43> N=230;n=[-N/2:N/2];n(N+1)=[];freq=n./N;

6. 将结果作图，我们使用：

        octave:

7. 现在的频率为：

        octave：46> i=

**刚才发生了什么**

在命令39中，我们月平均指数从0开始（0），总的呈上升趋势。我们仅将数据连接点相减。这里用线性方程y=ax+b,其中x为月指数，a通过计算为0.096。这会产生一个新的数据集，终点值为0。但是其他值是负的，这种偏差通过命令42除去。命令43-45是非常清楚的，但是，注意我们使用了通常的频率，而不是角频率。命令46中使用find来计算角频率。T=1/f。

总而言之， 傅里叶分析使fft函数可以通过下面的步骤完成：

1. 考虑一下是否需要去除趋势，如果需要的，先去除趋势；

2. 使用fft函数对你的数据进行傅里叶变换；

3. 通过fftshift函数来重新调整输出；

4. 生产样本的频率，记住要取出最后的高频区；

5. 对正频部分进行作图；

6. 高频是否为0?如果不是得话，是否有aliasing问题。

**傅里叶变换逆运算和数据平滑化处理**

在汇率数据处理中，我们发现去除噪音是非常有用的方。因为，噪音模糊化了数据中隐藏的特性。不附有任何意义。这种噪音会在高频区表现出来。我们可以用这种现象来做一些有用的东西吗？答案是肯定的。思路是这样的。我们可以将高频设定为0。再进行逆傅里叶变换。我们仍然可以看到缓慢变动的趋势。但是不再有高频。我们唯一需要注意的是，我们如何删除不需要的频率。Octave中会采用逆傅里叶变换。

与方程（7.14）类似，离散逆傅里叶变换如下：

$$f_k=\frac{1}{2\pi}\sum_{n=1}^n F$$

Octave中逆傅里叶变换函数ifft与fft函数语法一致。

最简单的形式如下：f=ifft(F)

在我们进行尝试之前，我们需要简单地讨论一下如何在谱中选取低频部分。

**Butterworst过滤器**

下面的函数被称为Butterworth函数的n次腼：

$$h(\omega)=\sqrt \frac{1}{1-(\omega/\omega_c)^{2n}}{},(7,20)$$

其中$\omega_c$为关键频率，5次方Butterworth函数在范围1-5有5个关键频率，注意到Butterworth $\omega$=0时，Butterworth函数为1.对于高频区会倾向于0。

现在我们可以使用Buttworth函数与进行傅里叶变换数据。现在我们的，设定高频为0.这正是我们想要的。

读者也可以运用其他类型的过滤函数，其中一些

特别注意，Butterworh过滤是平滑变动函数，要防止出现边缘效应，通常出现在步进过滤函数里。

**实战时刻-应用低频过滤函数**

1. 继续命令39-46，让我们应用10级Butterworth，$\omega_c=0.1$来平滑化无趋势数据，参见命令42：

        octave: 47>b_order=10;w_c=0.1;

2. Butterworth函数如下：

        octave：48>w=sqrt(1./(1+freq./uc).^(2*b_order));

3. 我们选择重排Butterworth窗口函数，或者说数据在相乘以前重排数据，我们用窗口函数重排数据：

        octave：49>w=fftshift(w);

4. 为了将过滤函数应用于cuur傅里叶变换，然后进行逆傅里叶变换，我们使用：

        octave：50>plot(m_index,ifft(fft(curr2).w),'r',\
                  >m_index,curr2,'b');

5. 结果如下所示，平滑化后的数据使用逆逆曲线给出。

**刚才发生了什么**

在命令47中，我们指定了关键过滤函数和Butterworth级数参数，没有任何技巧来选择特别的函数。

但是将得到的Butterworth过滤函数作图来判断是否将实际频率去除或者通过抑制是很好的想法。Butterworth函数重排是很重要的。我们使用命令49来说运行。在命令50中，我么将过滤函数应用于傅里叶变换过的数据中。逆变换傅里叶变换数据得到时域。与未过滤数据一起作用。

注意，Butterworth函数和一些许多其他类型过滤函数一起在信号处理软件包中提供。

**进一步深入--实现自己的傅里叶变换函数**

在练习中，读者将会编写自己的傅里叶变换函数，语法为

        [F freq]=fft(f,dt)

其中F为傅里叶变换数据，freq为向量独立的频率。f是输入函数，dt为间隔。函数应使用方程（7.14）和（7.15），而不是fft和ifft函数。

使用方程（7.17）来测试fft与相应的。顺便问一下，知道函数名称为什么是sft。

**总结**

在本章中，我们学习了：

* Octave可以倒入的数据；

* 如何用Octave对不同的统计矩来进行简单的统计描述；

* 如何用corr和t_test对2组之间数据进行比较；

* 如何用polyfit和拟合不同函数数据；

* 快速fft函数；

* 如何使用逆傅里叶函数ifft；

我们现在进入最后一章学习，读者会学习如何性能优化技术和动态链接技术。
